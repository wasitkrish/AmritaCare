<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AmritaCare</title>
<link rel="icon" href="/assets/logo.jpeg" type="image/jpeg">
<!-- Use compiled Tailwind CSS instead of CDN for reliability on Vercel -->
<link rel="stylesheet" href="styles.css">
<style>
  :root{
    --bg: #f8fafc;
    --card-bg: #ffffff;
    --muted: #6b7280;
    --text: #0f172a;
    --accent-1:#6366f1;
    --accent-2:#8b5cf6;
    --arrow:#111827;
    --dot-active:#111827;
    --dot-inactive:rgba(255,255,255,0.45);
    --glow-light: rgba(99,102,241,0.10);
    --glow-strong: rgba(139,92,246,0.08);
  }
  .dark{
    --bg:#071428;
    --card-bg:#0b1b2a;
    --muted:#9ca3af;
    --text:#e6eef7;
    --arrow:#e6eef7;
    --dot-active:#e6eef7;
    --dot-inactive:rgba(255,255,255,0.2);
    --glow-light: rgba(99,102,241,0.06);
    --glow-strong: rgba(139,92,246,0.16);
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;}
  body{background:var(--bg); color:var(--text); -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
  .muted{ color:var(--muted); }

  /* Footer link that matches theme accent colors */
  footer .footer-link{ color:var(--accent-1); font-weight:600; text-decoration:none; transition:color .18s ease, text-shadow .18s ease; }
  footer .footer-link:hover{ color:var(--accent-2); text-decoration:underline; text-shadow:0 2px 10px var(--glow-light); }

  /* --- Cards: subtle purple glow while preserving original shadows --- */
  .card{
    background:var(--card-bg);
    border-radius:14px;
    /* original soft shadow + subtle purple ambient glow */
    box-shadow:
      0 8px 30px rgba(2,6,23,0.06),
      0 8px 30px var(--glow-light),
      0 0 20px var(--glow-strong);
    transition: box-shadow .22s ease, transform .12s ease;
  }
  .card:hover{
    transform: translateY(-4px);
    box-shadow:
      0 12px 36px rgba(2,6,23,0.08),
      0 14px 40px var(--glow-light),
      0 0 28px var(--glow-strong);
  }

  .form-input{ width:100%; padding:.6rem .75rem; border-radius:8px; border:1px solid rgba(2,6,23,0.06); background:transparent; color:inherit; }
  .form-input::placeholder{ color:var(--muted); }
  .form-input:focus{ outline:none; box-shadow:0 8px 30px rgba(99,102,241,0.06); border-color:var(--accent-1); }

  .toggle-switch{ width:56px; height:30px; border-radius:9999px; background: linear-gradient(90deg,var(--accent-1),var(--accent-2)); cursor:pointer; padding:3px; display:inline-flex; align-items:center; }
  .toggle-ball{ width:24px; height:24px; border-radius:9999px; background:#fff; transform:translateX(0); transition:transform .28s ease; display:flex; align-items:center; justify-content:center; font-size:12px; }
  .dark .toggle-ball{ transform:translateX(26px); background:#facc15; }

  .reveal{ opacity:1; transform:none; transition:opacity .32s ease, transform .32s ease; }
  .reveal.visible{ opacity:1; transform:none; }

  /* gallery */
  .gallery-viewport{ 
    position:relative; 
    overflow:hidden; 
    border-radius:12px; 
    background:#000; 
    width: 100%;
    height: auto;
    min-height: 400px;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
  .gallery-track{ 
    display:flex; 
    transition:transform .48s cubic-bezier(.2,.9,.12,1); 
    will-change:transform;
    width: 100%;
    height: 100%;
    min-height: 400px;
  }
  .video-slide{ 
    flex:0 0 100%; 
    position:relative; 
    display:flex; 
    align-items:center; 
    justify-content:center; 
    width: 100%;
    height: 100%;
  }
  .video-slide video,
  .video-slide iframe.yt-embed{ 
    width:100%; 
    border-radius:12px; 
    display:block; 
    background:#000;
  }
  .video-slide iframe.yt-embed {
    aspect-ratio: 16/9;
    height: auto;
    max-width: 100%;
  }

  /* Centered overlay controls (only visible on hover / touch-active) */
  .video-overlay{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
    opacity:0;
    transition:opacity .18s ease;
    z-index:35;
  }
  /* appear on hover or touch-active */
  .video-slide:hover .video-overlay,
  .video-slide.touch-active .video-overlay { opacity:1; pointer-events:auto; }

  .controls {
    display:flex;
    gap:10px;
    align-items:center;
    justify-content:center;
    padding:8px;
    border-radius:999px;
    /* translucent dark backdrop for buttons */
    background: linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0.45));
    backdrop-filter: blur(6px);
    pointer-events:auto;
    transition: transform .16s ease, box-shadow .16s ease, opacity .12s ease;
    transform: translateY(0);
    margin: 0 auto;
    width: fit-content;
  }
  .controls:has(.ctrl-btn:hover) { transform: translateY(-2px); }

  /* buttons: purple accent, rounded, hover animation */
  .ctrl-btn{
    width:48px;
    height:48px;
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:9999px;
    background: linear-gradient(90deg,var(--accent-1),var(--accent-2));
    color:#fff;
    cursor:pointer;
    border: none;
    font-size:18px;
    transition: transform .14s ease, box-shadow .14s ease, opacity .14s ease;
    box-shadow: 0 6px 18px rgba(99,102,241,0.14);
    will-change:transform;
  }
  .ctrl-btn:hover{ transform: scale(1.06); box-shadow: 0 10px 28px rgba(99,102,241,0.18); }
  .ctrl-btn:active{ transform: scale(.98); }

  /* fallback style for old browsers (keeps look consistent) */
  .ctrl-btn.fallback { background: rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.08); color:#fff; }

  .gallery-fade{ position:absolute; inset:0; pointer-events:none; opacity:0; transition:opacity .18s ease; z-index:30; background:linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0.06)); }
  .gallery-fade.active{ opacity:1; }

  .side-arrow{
    position:absolute; top:50%; transform:translateY(-50%); width:44px; height:44px; border-radius:8px; display:flex; align-items:center; justify-content:center; cursor:pointer; z-index:40;
    background:linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.9)); border:1px solid rgba(2,6,23,0.06); color:var(--arrow); transition:transform .12s ease, box-shadow .12s ease;
  }
  .side-arrow:hover{ transform:translateY(-50%) scale(1.06); box-shadow:0 8px 20px rgba(2,6,23,0.12); }
  .dark .side-arrow{ background:linear-gradient(180deg, rgba(12,17,26,0.72), rgba(17,24,39,0.72)); border:1px solid rgba(255,255,255,0.04); color:var(--arrow); }
  .side-arrow.left{ left:12px; } .side-arrow.right{ right:12px; }
  @media (max-width:640px){ .side-arrow{ width:40px; height:40px; } }

  .indicators{ position:absolute; left:50%; transform:translateX(-50%); bottom:12px; display:flex; gap:8px; z-index:45; }
  .video-counter{ 
    padding: 6px 14px; 
    border-radius: 999px; 
    background: linear-gradient(180deg, rgba(0,0,0,0.65), rgba(0,0,0,0.75)); 
    backdrop-filter: blur(8px);
    color: #fff; 
    font-size: 13px; 
    font-weight: 600; 
    letter-spacing: 0.5px;
    border: 1px solid rgba(255,255,255,0.15);
    box-shadow: 0 4px 12px rgba(0,0,0,0.25);
  }

  /* stories */
  .stories-section{ 
    position:relative; 
    overflow:hidden; 
    padding-top: 24px;
    padding-bottom: 40px;
  }
  .stories-viewport{
    /* Manual horizontal scroll */
    overflow-x: auto;
    overflow-y: hidden;
    padding-top: 20px;
    padding-bottom: 8px;
    scroll-snap-type: x mandatory;
    -webkit-overflow-scrolling: touch;
  }
  .stories-viewport::-webkit-scrollbar{ height:6px; }
  .stories-viewport::-webkit-scrollbar-track{ background:transparent; }
  .stories-viewport::-webkit-scrollbar-thumb{ background:rgba(99,102,241,0.35); border-radius:4px; }
  .dark .stories-viewport::-webkit-scrollbar-thumb{ background:rgba(139,92,246,0.4); }
  .stories-track{
    display:flex;
    gap:16px;
    align-items:stretch;
    scroll-snap-type: inherit;
    /* remove transform-based carousel behavior */
  }
  .review-card{
    width:calc((100% - (16px * 4))/5); 
    aspect-ratio:1/1; 
    flex:0 0 auto; 
    border-radius:14px; 
    padding:1.5rem; 
    background:var(--card-bg);
    border: 1px solid rgba(2,6,23,0.06);
    box-shadow:
      0 4px 6px -1px rgba(0,0,0,0.05),
      0 2px 4px -1px rgba(0,0,0,0.03);
    color:var(--text); 
    transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    will-change: transform, box-shadow;
    position: relative;
    overflow: hidden;
    cursor: pointer;
  }
  .review-card::before{
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--accent-1), var(--accent-2));
    opacity: 0;
    transition: opacity 0.4s ease;
    border-radius: 14px;
  }
  .review-card > * {
    position: relative;
    z-index: 1;
  }
  .review-card{ scroll-snap-align:start; }
  .review-card:hover{ 
    transform: translateY(-16px) scale(1.05); 
    box-shadow: 
      0 25px 50px -12px rgba(0,0,0,0.15),
      0 0 0 1px rgba(99,102,241,0.2),
      0 0 50px var(--glow-light);
    z-index:60;
    border-color: rgba(99,102,241,0.3);
  }
  .review-card:hover::before{
    opacity: 0.08;
  }
  .dark .review-card{ 
    background:var(--card-bg);
    border: 1px solid rgba(255,255,255,0.08);
    box-shadow:
      0 4px 6px -1px rgba(0,0,0,0.3),
      0 2px 4px -1px rgba(0,0,0,0.2);
  }
  .dark .review-card:hover{
    box-shadow: 
      0 25px 50px -12px rgba(0,0,0,0.5),
      0 0 0 1px rgba(139,92,246,0.4),
      0 0 50px var(--glow-strong);
    border-color: rgba(139,92,246,0.4);
  }

  .stories-arrow{
    display:none; /* Removed: arrows hidden in favor of auto-scroll + mouse/touch drag */
  }

  /* Desktop: 5 cards per row */
  @media (min-width:1400px){ 
    .review-card{ width:calc((100% - (16px * 4))/5); padding:1.5rem; }
    .stories-track{ gap:16px; }
    .review-card .font-semibold { font-size: 1rem; }
    .review-card .text-xs { font-size: 0.75rem; }
    .review-card .text-sm { font-size: 0.875rem; }
  }

  /* Large tablet: 3 cards per row */
  @media (min-width:768px) and (max-width:1399px){ 
    .review-card{ width:calc((100% - (16px * 2))/3); padding:1.5rem; }
    .stories-track{ gap:16px; }
    .review-card .font-semibold { font-size: 0.95rem; }
    .review-card .text-xs { font-size: 0.7rem; }
    .review-card .text-sm { font-size: 0.85rem; }
  }

  /* Small tablet: 2 cards per row */
  @media (min-width:480px) and (max-width:767px){ 
    .review-card{ width:calc((100% - 16px)/2); padding:1.25rem; }
    .stories-track{ gap:16px; }
    .review-card .font-semibold { font-size: 0.9rem; }
    .review-card .text-xs { font-size: 0.65rem; }
    .review-card .text-sm { font-size: 0.8rem; }
  }

  /* Mobile: 1 card per row */
  @media (max-width:479px){ 
    .review-card{ width:100%; padding:1rem; }
    .stories-track{ gap:12px; }
    .review-card .font-semibold { font-size: 0.85rem; }
    .review-card .text-xs { font-size: 0.6rem; }
    .review-card .text-sm { font-size: 0.75rem; }
  }

  /* overlays */
  .overlay { position:fixed; inset:0; background:rgba(2,6,23,0.35); display:flex; align-items:center; justify-content:center; z-index:60; }
  .modal { width:100%; max-width:460px; border-radius:12px; padding:18px; background:var(--card-bg); box-shadow:0 12px 40px rgba(2,6,23,0.2); }

  /* ensure header matches body color in both themes (overrides Tailwind utility) */
  header { background: var(--bg); }
  .dark header { background: var(--bg); }

  .hidden{ display:none !important; }

  /* ===== REALTIME CHAT STYLING ===== */
  
  #chatCard {
    display: flex !important;
    flex-direction: column !important;
    gap: 0 !important;
  }
  
  #chatWindow {
    max-height: 250px !important;
    overflow-y: auto !important;
    overflow-x: hidden !important;
    display: flex !important;
    flex-direction: column !important;
    gap: 8px !important;
    background: var(--card-bg) !important;
    border-radius: 8px !important;
    padding: 12px !important;
    scroll-behavior: smooth !important;
    margin-bottom: 12px !important;
  }
  
  /* Individual message containers */
  .chat-message-other {
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: flex-start;
  }
  
  .chat-message-own {
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: flex-end; /* own messages align to the right */
    flex-direction: row;
  }
  
  /* Avatar */
  .chat-avatar {
    width: 32px;
    height: 32px;
    min-width: 32px;
    min-height: 32px;
    border-radius: 50%;
    background: linear-gradient(135deg, #6366f1, #8b5cf6);
    color: white;
    font-weight: 700;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    margin: 0; /* ensure vertical centering inside message container */
  }
  
  /* Message content wrapper */
  .chat-content {
    display: flex;
    flex-direction: column;
    gap: 3px;
    max-width: 70%;
    word-wrap: break-word;
  }
  
  .chat-message-own .chat-content {
    align-items: flex-end; /* align own content to the right of the bubble */
    text-align: right;
  }

  .chat-message-other .chat-content {
    align-items: flex-start;
    text-align: left;
  }
  
  /* Header: Name and timestamp */
  .chat-header {
    font-size: 11px;
    color: var(--muted);
    font-weight: 500;
  }
  
  .chat-header strong {
    color: var(--text);
    font-weight: 600;
    margin-right: 4px;
  }
  
  .chat-message-own .chat-header strong {
    margin-right: 4px;
    margin-left: 0;
  }
  
  /* Message bubble - IDENTICAL STYLING FOR ALL MESSAGES */
  .chat-bubble-own,
  .chat-bubble-other {
    padding: 8px 12px !important;
    border-radius: 12px !important;
    line-height: 1.3 !important;
    word-wrap: break-word !important;
    font-size: 13px !important;
    background: var(--card-bg) !important;
    color: var(--text) !important;
    border: 1px solid rgba(99, 102, 241, 0.2) !important;
  }
  
  .dark .chat-bubble-own,
  .dark .chat-bubble-other {
    border-color: rgba(139, 92, 246, 0.3) !important;
  }
  /* Actions (Report button) */
  .chat-actions {
    display: flex;
    gap: 4px;
    font-size: 10px;
  }
  
  .report-btn {
    background: none;
    border: none;
    color: var(--accent-2);
    cursor: pointer;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 3px;
    transition: all 0.2s ease;
    font-weight: 500;
  }
  
  .report-btn:hover {
    background: rgba(239, 68, 68, 0.1);
    color: #dc2626;
  }
  
  /* Scrollbar styling */
  #chatWindow::-webkit-scrollbar {
    width: 6px;
  }
  
  #chatWindow::-webkit-scrollbar-track {
    background: transparent;
  }
  
  #chatWindow::-webkit-scrollbar-thumb {
    background: rgba(99, 102, 241, 0.3);
    border-radius: 3px;
  }
  
  #chatWindow::-webkit-scrollbar-thumb:hover {
    background: rgba(99, 102, 241, 0.5);
  }
  
  .dark #chatWindow::-webkit-scrollbar-thumb {
    background: rgba(139, 92, 246, 0.4);
  }
  
  .dark #chatWindow::-webkit-scrollbar-thumb:hover {
    background: rgba(139, 92, 246, 0.6);
  }
  
  /* Mobile responsive */
  @media (max-width: 768px) {
    #chatWindow {
      max-height: 220px !important;
      padding: 10px !important;
      gap: 6px !important;
    }
    .chat-content {
      max-width: 78% !important;
      gap: 2px !important;
    }
    .chat-avatar {
      width: 30px !important;
      height: 30px !important;
      font-size: 11px !important;
    }
    .chat-bubble-own,
    .chat-bubble-other {
      padding: 7px 10px !important;
      font-size: 12px !important;
    }
    .chat-header {
      font-size: 10px !important;
    }
  }
  
  @media (max-width: 640px) {
    #chatWindow {
      max-height: 200px !important;
      padding: 8px !important;
      gap: 6px !important;
    }
    
    .chat-avatar {
      width: 28px !important;
      height: 28px !important;
      font-size: 10px !important;
    }
    
    .chat-content {
      max-width: 82% !important;
      gap: 2px !important;
    }
    
    .chat-bubble-own,
    .chat-bubble-other {
      padding: 6px 9px !important;
      font-size: 11px !important;
      border-radius: 10px !important;
    }
    
    .chat-header {
      font-size: 9px !important;
    }
    
    .chat-actions {
      font-size: 9px;
    }
    
    .report-btn {
      font-size: 9px;
      padding: 1px 4px;
    }
  }

  /* Featured Images Slideshow - responsive height that follows image */
  .images-section{ position:relative; }
  .images-viewport{
    position:relative;
    overflow:hidden;
    border-radius:12px;
    background: transparent;
    display:block;
  }
  .dark .images-viewport{ background: transparent; }
  .images-track{
    display:flex;
    transition:transform .5s cubic-bezier(.2,.9,.12,1);
    will-change:transform;
    width:100%;
    height:auto;
    align-items:center;
  }
  .image-slide{
    flex:0 0 100%;
    flex-shrink: 0;
    position:relative;
    height:auto;
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    padding: 0;
  }
  .dark .image-slide{ background: transparent; }
  .image-slide img{
    width: 100%;
    height: auto;
    max-width: 100%;
    object-fit: contain;
    border-radius:8px;
    display:block;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
  }

  /* Mobile tweaks: reduce padding so viewport closely wraps image */
  @media (max-width:640px){
    .images-viewport{ padding:0; }
    .image-slide{ padding:0; }
  }
  
  .images-arrow{
    position:absolute; top:50%; transform:translateY(-50%); width:44px; height:44px; border-radius:8px; display:flex; align-items:center; justify-content:center; cursor:pointer; z-index:40;
    background:linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.9)); border:1px solid rgba(2,6,23,0.06); color:var(--arrow); transition:transform .12s ease, box-shadow .12s ease;
  }
  .images-arrow:hover{ transform:translateY(-50%) scale(1.06); box-shadow:0 8px 20px rgba(2,6,23,0.12); }
  .dark .images-arrow{ background:linear-gradient(180deg, rgba(12,17,26,0.72), rgba(17,24,39,0.72)); border:1px solid rgba(255,255,255,0.04); color:var(--arrow); }
  .images-arrow.left{ left:12px; } .images-arrow.right{ right:12px; }
  
  .images-indicators{ position:absolute; left:50%; transform:translateX(-50%); bottom:12px; display:flex; gap:8px; z-index:45; }
  .image-dot{ width:10px; height:10px; border-radius:999px; background:var(--dot-inactive); transition:transform .14s ease, background .18s ease; cursor:pointer; border:1px solid rgba(0,0,0,0.06); }
  .image-dot.active{ background:var(--dot-active); transform:scale(1.12); }
  #chatWindow::-webkit-scrollbar {
    width: 6px;
  }
  #chatWindow::-webkit-scrollbar-track {
    background: transparent;
  }
  #chatWindow::-webkit-scrollbar-thumb {
    background: rgba(99,102,241,0.3);
    border-radius: 3px;
  }
  #chatWindow::-webkit-scrollbar-thumb:hover {
    background: rgba(99,102,241,0.5);
  }
  .dark #chatWindow::-webkit-scrollbar-thumb {
    background: rgba(139,92,246,0.4);
  }
  .dark #chatWindow::-webkit-scrollbar-thumb:hover {
    background: rgba(139,92,246,0.6);
  }

  /* --- Upload button improvements --- */
  .upload-btn {
    display:inline-flex;
    align-items:center;
    gap:10px;
    padding:.55rem .75rem;
    border-radius:999px;
    font-size:.95rem;
    font-weight:600;
    cursor:pointer;
    user-select:none;
    transition: transform .14s ease, box-shadow .18s ease, background .14s ease;
    background: linear-gradient(90deg,var(--accent-1),var(--accent-2));
    color: #fff;
    box-shadow: 0 8px 24px rgba(99,102,241,0.14);
    border: none;
  }
  .upload-btn:hover { transform: translateY(-3px); box-shadow: 0 14px 36px rgba(99,102,241,0.18); }
  .upload-btn:active { transform: translateY(-1px) scale(.99); }

  /* file chosen small tag */
  .file-selected {
    font-size: .85rem;
    color: var(--muted);
    max-width: 160px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  /* responsive adjustments for upload area */
  @media (max-width:640px){
    .upload-btn { padding:.5rem .65rem; font-size:.92rem; gap:8px; }
    .ctrl-btn{ width:44px; height:44px; font-size:16px; }
  }

  /* Uniform styling for all inputs and textareas */
.form-input,
textarea.form-input,
input.form-input {
  width: 100%;
  padding: 0.65rem 0.75rem;
  border-radius: 8px;
  border: 1px solid rgba(2,6,23,0.08);
  background: transparent;
  color: inherit;
  transition: all 0.25s ease;
  font-size: 0.95rem;
}
/* Prevent manual resizing of textareas to keep layout consistent */
textarea.form-input { resize: none; }

/* Placeholder color */
.form-input::placeholder {
  color: var(--muted);
  opacity: 0.9;
}

/* Hover effect (subtle lift and border highlight) */
.form-input:hover {
  border-color: var(--accent-1);
  box-shadow: 0 4px 14px rgba(99, 102, 241, 0.06);
}

/* Focus effect (stronger accent glow) */
.form-input:focus {
  outline: none;
  border-color: var(--accent-1);
  box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.25);
  background: rgba(99, 102, 241, 0.04);
}

/* Disabled state consistency */
.form-input:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* Dark mode improvements */
.dark .form-input {
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(17,24,39,0.35);
}
.dark .form-input:hover {
  border-color: var(--accent-2);
  box-shadow: 0 4px 14px rgba(139, 92, 246, 0.15);
}
.dark .form-input:focus {
  border-color: var(--accent-2);
  box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.3);
  background: rgba(139, 92, 246, 0.08);
}

</style>
</head>
<body>

<!-- Header -->
<header class="sticky top-0 z-50">
  <div class="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between">
    <div class="flex items-center gap-3">
      <img src="/assets/logo.jpeg" alt="AmritaCare logo" class="h-10 w-10 rounded-xl object-contain bg-black"
           onerror="this.classList.add('hidden'); const f=document.getElementById('brandFallback'); if(f) f.classList.remove('hidden');">
      <div id="brandFallback" class="h-10 w-10 rounded-full bg-gradient-to-br from-indigo-600 to-purple-600 flex items-center justify-center text-white font-bold hidden">MH</div>
      <h1 class="text-lg font-bold text-indigo-700 dark:text-indigo-300">AmritaCare</h1>
    </div>

    <div class="flex items-center gap-3">
      <div id="themeToggle" class="toggle-switch" role="button" tabindex="0"><div id="toggleBall" class="toggle-ball">ðŸŒ™</div></div>
      <button id="loginBtn" class="px-3 py-2 rounded-full bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-semibold">Login</button>
      <button id="profileBtn" class="px-3 py-2 rounded-full bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-semibold hidden">My Profile</button>
    </div>
  </div>
</header>

<!-- Featured Experiences -->
<section class="py-6 reveal">
  <div class="max-w-6xl mx-auto px-4">
    <div class="flex items-center justify-between mb-4">
      <h2 class="text-2xl sm:text-3xl font-semibold text-indigo-700 dark:text-indigo-300">Featured Messages</h2>
    </div>

    <div class="relative gallery-viewport card" id="galleryViewport">
      <div id="galleryFade" class="gallery-fade"></div>

      <button id="prevVideo" class="side-arrow left" aria-label="Previous">â€¹</button>

      <div id="galleryTrack" class="gallery-track">
        <!-- 14 YouTube slides with direct iframes -->
        <div class="video-slide">
          <iframe class="yt-embed" loading="lazy" src="https://www.youtube.com/embed/j1WcDEZuweU?rel=0&modestbranding=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
        </div>
        <div class="video-slide">
          <iframe class="yt-embed" loading="lazy" src="https://www.youtube.com/embed/U4xifNiIGZo?rel=0&modestbranding=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
        </div>
        <div class="video-slide">
          <iframe class="yt-embed" loading="lazy" src="https://www.youtube.com/embed/6KRwUijc9ss?rel=0&modestbranding=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
        </div>
        <div class="video-slide">
          <iframe class="yt-embed" loading="lazy" src="https://www.youtube.com/embed/SBrrZXik4GY?rel=0&modestbranding=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
        </div>
        <div class="video-slide">
          <iframe class="yt-embed" loading="lazy" src="https://www.youtube.com/embed/k1Ywgchdww8?rel=0&modestbranding=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
        </div>
        <div class="video-slide">
          <iframe class="yt-embed" loading="lazy" src="https://www.youtube.com/embed/NL_GJhF5HJo?rel=0&modestbranding=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
        </div>
        <div class="video-slide">
          <iframe class="yt-embed" loading="lazy" src="https://www.youtube.com/embed/oLJ9JxXsRrs?rel=0&modestbranding=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
        </div>
        <div class="video-slide">
          <iframe class="yt-embed" loading="lazy" src="https://www.youtube.com/embed/Gg7o-2OGvn0?rel=0&modestbranding=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
        </div>
        <div class="video-slide">
          <iframe class="yt-embed" loading="lazy" src="https://www.youtube.com/embed/zigJS7lXcus?rel=0&modestbranding=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
        </div>
        <div class="video-slide">
          <iframe class="yt-embed" loading="lazy" src="https://www.youtube.com/embed/52YWPgDIVrE?rel=0&modestbranding=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
        </div>
        <div class="video-slide">
          <iframe class="yt-embed" loading="lazy" src="https://www.youtube.com/embed/_kBEp5LdC3I?rel=0&modestbranding=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
        </div>
        <div class="video-slide">
          <iframe class="yt-embed" loading="lazy" src="https://www.youtube.com/embed/c_6PROln27Q?rel=0&modestbranding=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
        </div>
        <div class="video-slide">
          <iframe class="yt-embed" loading="lazy" src="https://www.youtube.com/embed/n-t-3eA4v9E?rel=0&modestbranding=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
        </div>
        <div class="video-slide">
          <iframe class="yt-embed" loading="lazy" src="https://www.youtube.com/embed/KYnAlm3jZuk?rel=0&modestbranding=1" frameborder="0" allow="accelerometer; autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
        </div>
      </div>

      <button id="nextVideo" class="side-arrow right" aria-label="Next">â€º</button>
    </div>

    <!-- ADMIN modal (outside gallery) -->
    <div id="adminOverlay" class="overlay hidden">
      <div class="modal" style="max-width:900px; width:95%;">
        <div class="flex items-center justify-between mb-3">
          <h4 class="text-lg font-semibold">Admin Dashboard â€” Reported Chats</h4>
          <button id="closeAdmin" class="text-sm muted">âœ•</button>
        </div>
        <div id="adminContent" style="max-height:60vh; overflow:auto;"></div>
        <div class="mt-3 text-right">
          <button id="adminRefresh" class="px-3 py-2 rounded-full bg-gray-100 text-gray-800">Refresh</button>
        </div>
      </div>
    </div>
  </div>
</section>

<!-- Main: Share + Chat + Reach Out -->
<main class="flex-1 max-w-6xl mx-auto px-4 py-8 space-y-8 w-full">
  <section class="reveal">
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <!-- Top Row: Realtime Chat and Share Your Experience -->
      <div id="chatCard" class="card p-6 bg-white dark:bg-gray-800 border border-gray-100 dark:border-gray-700">
        <!-- Chat Header -->
        <div class="flex items-center justify-between mb-4 pb-4 border-b border-gray-200 dark:border-gray-700">
          <div>
            <h3 class="text-lg font-semibold text-indigo-700 dark:text-indigo-300">Realtime Chat</h3>
            <p class="text-sm muted">Login to send messages.</p>
          </div>
          <div class="flex items-center gap-3">
            <button id="clearChatBtn" class="text-xs px-3 py-1 rounded-full bg-red-600 text-white hover:bg-red-700 transition-colors hidden" title="Admin only">Clear Chat</button>
            <span class="inline-flex items-center gap-1">
              <span class="h-2 w-2 rounded-full bg-green-500 animate-pulse"></span>
              <span class="text-xs font-medium text-green-600 dark:text-green-400">Live</span>
            </span>
          </div>
        </div>

        <!-- Messages Container -->
        <div id="chatWindow" class="p-4 bg-gray-50 dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-700"></div>

        <!-- Input Area -->
        <div class="flex flex-col gap-3">
          <div class="flex items-end gap-2">
            <input 
              id="messageInput" 
              type="text"
              class="form-input flex-1" 
              placeholder="Type a message..."
              autocomplete="off"
            />
            <div class="relative">
              <button 
                id="emojiBtn" 
                type="button"
                class="px-3 py-2 rounded-lg bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors text-lg leading-none"
              >ðŸ˜Š</button>
              <div id="emojiPicker" class="hidden absolute bottom-12 right-0 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-lg p-3 shadow-xl z-50" style="width:220px;">
                <div class="grid grid-cols-6 gap-2" id="emojiList">
                  <!-- emojis inserted by JS -->
                </div>
              </div>
            </div>
            <button 
              id="sendBtn" 
              type="button"
              class="px-4 py-2 rounded-lg bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-semibold hover:from-indigo-700 hover:to-purple-700 transition-all"
            >Send</button>
          </div>
        </div>
      </div>

      <!-- Share Your Experience -->
      <div class="card p-6 bg-white dark:bg-gray-800 border border-gray-100 dark:border-gray-700">
        <h3 class="text-lg font-semibold text-indigo-700 dark:text-indigo-300">Share Your Experience</h3>
        <p class="text-sm muted mt-2">Write a short message â€” upload a photo or short video.</p>

        <label class="block mt-4 text-sm">Message</label>
        <textarea id="shareMessage" rows="4" class="form-input mt-2" placeholder="Your message..."></textarea>

        <div class="mt-3 flex items-center gap-3">
          <!-- improved upload button -->
          <label for="shareFile" id="uploadLabel" class="upload-btn">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M3 13a4 4 0 004 4h6a4 4 0 100-8 5 5 0 10-9.9.9" /></svg>
            <span>Choose photo/video</span>
          </label>
          <input id="shareFile" type="file" accept="image/*,video/*" class="hidden"/>
          <div id="fileName" class="text-sm file-selected muted">No file chosen</div>
        </div>

        <div class="mt-4 flex items-center justify-between">
          <div class="text-xs muted">Max 200MB.</div>
          <button id="shareSend" class="px-3 py-2 rounded-full bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-semibold">Send</button>
        </div>
      </div>

      <!-- Reach Out For Help -->
      <div id="reachCard" class="card p-6 bg-white dark:bg-gray-800 border border-gray-100 dark:border-gray-700 flex flex-col">
        <h3 class="text-lg font-semibold text-indigo-700 dark:text-indigo-300">Reach Out For Help</h3>
        <p class="text-sm muted mt-2">If you'd like someone to contact you, fill out the form below.</p>

  <form id="contactForm" class="grid grid-cols-1 gap-4 mt-4 flex-1" action="https://formsubmit.co/singhkrish.np@gmail.com" method="POST">
          <!-- FormSubmit (https://formsubmit.co) will send submissions to singhkrish.np@gmail.com -->
          <!-- Honeypot to reduce spam -->
          <input type="text" name="_honey" style="display:none !important" tabindex="-1" autocomplete="off">
          <!-- Disable FormSubmit captcha (optional) -->
          <input type="hidden" name="_captcha" value="false">
          <!-- Optional: customize email subject -->
          <input type="hidden" name="_subject" value="AmritaCare: New contact form submission">
          <input name="name" placeholder="Your Name" class="form-input" required />
          <input name="email" type="email" placeholder="Your Email" class="form-input" required />
          <textarea name="message" rows="4" placeholder="How can we help?" class="form-input flex-1" required></textarea>
          <div class="text-right">
            <button type="submit" class="px-3 py-2 rounded-full bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-semibold">Send</button>
          </div>
          <div id="contactStatus" class="text-sm mt-2" aria-live="polite"></div>
        </form>
      </div>

      <!-- Bottom Row: Featured Images -->

      <!-- Featured Images -->
      <div class="card p-6 bg-white dark:bg-gray-800 border border-gray-100 dark:border-gray-700 images-section lg:row-start-1 lg:col-start-2">
        <div class="flex items-center justify-between mb-4">
          <h3 class="text-lg font-semibold text-indigo-700 dark:text-indigo-300">Featured Images</h3>
        </div>

        <div class="images-viewport">
          <button id="prevImage" class="images-arrow left" aria-label="Previous">â€¹</button>
          <button id="nextImage" class="images-arrow right" aria-label="Next">â€º</button>

          <div id="imagesTrack" class="images-track">
            <div class="image-slide">
              <img src="/assets/1.png" alt="Featured Image 1" loading="eager" decoding="async" />
            </div>
            <div class="image-slide">
              <img src="/assets/2.png" alt="Featured Image 2" loading="lazy" decoding="async" />
            </div>
            <div class="image-slide">
              <img src="/assets/3.png" alt="Featured Image 3" loading="lazy" decoding="async" />
            </div>
            <div class="image-slide">
              <img src="/assets/4.jpg" alt="Featured Image 4" loading="lazy" decoding="async" />
            </div>
            <div class="image-slide">
              <img src="/assets/5.png" alt="Featured Image 5" loading="lazy" decoding="async" />
            </div>
          </div>

          <div class="images-indicators">
            <div id="imgDot0" class="image-dot active" data-index="0"></div>
            <div id="imgDot1" class="image-dot" data-index="1"></div>
            <div id="imgDot2" class="image-dot" data-index="2"></div>
            <div id="imgDot3" class="image-dot" data-index="3"></div>
            <div id="imgDot4" class="image-dot" data-index="4"></div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Community Stories -->
  <section class="reveal stories-section card p-6 pt-8 bg-white dark:bg-gray-800 border border-gray-100 dark:border-gray-700">
    <div class="flex items-center justify-between mb-6">
      <div>
        <h3 class="text-xl font-semibold text-indigo-700 dark:text-indigo-300">Community Stories</h3>
        <p class="text-sm muted mt-1">Read experiences shared by our students and community members.</p>
      </div>
    </div>

    <div class="relative">
      <div class="stories-viewport">
        <div id="storiesTrack" class="stories-track">
          <div class="review-card">
            <div class="flex items-start justify-between mb-3">
              <div>
                <div class="font-semibold text-base">Piyush Jha</div>
                <div class="text-xs muted mt-1">Student</div>
              </div>
              <div class="text-2xl opacity-20">"</div>
            </div>
            <p class="text-sm leading-relaxed">This space helped me rediscover calm in tough times. The community support made all the difference.</p>
          </div>
          <div class="review-card">
            <div class="flex items-start justify-between mb-3">
              <div>
                <div class="font-semibold text-base">Mukund Sah</div>
                <div class="text-xs muted mt-1">Student</div>
              </div>
              <div class="text-2xl opacity-20">"</div>
            </div>
            <p class="text-sm leading-relaxed">I finally felt heard and supported. This platform provides a safe space for everyone to share.</p>
          </div>
          <div class="review-card">
            <div class="flex items-start justify-between mb-3">
              <div>
                <div class="font-semibold text-base">Roshan Sah</div>
                <div class="text-xs muted mt-1">Student</div>
              </div>
              <div class="text-2xl opacity-20">"</div>
            </div>
            <p class="text-sm leading-relaxed">A comforting place when I needed it most. The resources and community here are invaluable.</p>
          </div>
          <div class="review-card">
            <div class="flex items-start justify-between mb-3">
              <div>
                <div class="font-semibold text-base">Shan Divyesh</div>
                <div class="text-xs muted mt-1">Student</div>
              </div>
              <div class="text-2xl opacity-20">"</div>
            </div>
            <p class="text-sm leading-relaxed">Helped me understand my emotions better. The guidance and support here is truly meaningful.</p>
          </div>
          <div class="review-card">
            <div class="flex items-start justify-between mb-3">
              <div>
                <div class="font-semibold text-base">Manik srivastav</div>
                <div class="text-xs muted mt-1">Student</div>
              </div>
              <div class="text-2xl opacity-20">"</div>
            </div>
            <p class="text-sm leading-relaxed">Encouraged me to reach out and connect. This platform has been a positive influence in my journey.</p>
          </div>
        </div>
      </div>
    </div>
  </section>
</main>

<footer class="bg-white dark:bg-gray-900 border-t border-gray-100 dark:border-gray-700 py-6">
  <div class="max-w-6xl mx-auto px-4 text-sm muted text-center">Â© 2025 AmritaCare Â· A compassion driven project by <a href="https://linktr.ee/wasitkrish" class="footer-link">@wasitkrish</a></div>
</footer>

<!-- AUTH modal -->
<div id="authOverlay" class="overlay hidden">
  <div class="modal">
    <div class="flex items-center justify-between mb-3">
      <h4 id="authTitle" class="text-lg font-semibold">Login</h4>
      <button id="closeAuth" class="text-sm muted">âœ•</button>
    </div>

    <!-- Login -->
    <form id="loginForm" class="space-y-3">
      <input id="loginEmail" type="email" placeholder="Email" class="form-input" required />
      <input id="loginPassword" type="password" placeholder="Password" class="form-input" required />
      <div class="flex items-center justify-between">
        <button type="submit" class="px-3 py-2 rounded-full bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-semibold">Login</button>
        <button id="showSignup" type="button" class="text-sm text-indigo-600">Create account</button>
      </div>
    </form>

    <!-- Signup -->
    <form id="signupForm" class="space-y-3 hidden">
      <input id="signupName" placeholder="Name" class="form-input" required />
      <input id="signupEmail" type="email" placeholder="Email" class="form-input" required />
      <input id="signupPassword" type="password" placeholder="Password (min 6)" class="form-input" required />
      <div class="flex items-center justify-between">
        <button id="sendOtpBtn" type="button" class="px-3 py-2 rounded-full bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-semibold">Send OTP</button>
        <button id="showLogin" type="button" class="text-sm text-indigo-600">Back to login</button>
      </div>
    </form>

    <!-- OTP -->
    <form id="otpForm" class="space-y-3 hidden">
      <p class="text-sm muted">OTP sent to <span id="otpTarget"></span> (simulated)</p>
      <input id="otpInput" placeholder="Enter OTP" class="form-input" />
      <div class="flex items-center justify-between">
        <button id="verifyOtpBtn" type="button" class="px-3 py-2 rounded-full bg-indigo-600 text-white font-semibold">Verify OTP</button>
        <button id="resendOtpBtn" type="button" class="text-sm text-indigo-600">Resend</button>
      </div>
    </form>
  </div>
</div>

<!-- PROFILE modal -->
<div id="profileOverlay" class="overlay hidden">
  <div class="modal">
    <div class="flex items-center justify-between mb-3">
      <h4 class="text-lg font-semibold">Profile</h4>
      <button id="closeProfile" class="text-sm muted">âœ•</button>
    </div>
    <div class="space-y-3">
      <div><label class="text-sm">Email (unchangeable)</label><div id="profileEmail" class="p-2 bg-gray-50 dark:bg-gray-900 rounded-md"></div></div>
      <div><label class="text-sm">Name</label><input id="profileName" class="form-input" /></div>
      <div class="flex items-center gap-2">
        <button id="updateNameBtn" class="px-3 py-2 rounded-full bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-semibold">Update Name</button>
        <button id="changePasswordBtn" class="px-3 py-2 rounded-full bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-semibold">Change Password</button>
      </div>
      <div class="flex justify-between items-center">
        <div class="flex items-center gap-2">
          <button id="openAdminBtn" class="px-3 py-2 rounded-full bg-red-600 text-white font-semibold hidden">Admin Dashboard</button>
          <button id="logoutBtn" class="px-3 py-2 rounded-full bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-semibold">Logout</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* THEME */
const themeToggle = document.getElementById('themeToggle');
const toggleBall = document.getElementById('toggleBall');
function setTheme(t){ if(t==='dark'){ document.documentElement.classList.add('dark'); toggleBall.innerText='â˜€ï¸'; } else { document.documentElement.classList.remove('dark'); toggleBall.innerText='ðŸŒ™'; } }
const stored = localStorage.getItem('mh_theme');
setTheme(stored || (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'));
themeToggle.addEventListener('click', ()=>{ const next = document.documentElement.classList.contains('dark') ? 'light' : 'dark'; setTheme(next); localStorage.setItem('mh_theme', next); });

/* reveals */
const reveals = document.querySelectorAll('.reveal');
const io = new IntersectionObserver(entries=> entries.forEach(e=> { if(e.isIntersecting) e.target.classList.add('visible'); }), { threshold: .08 });
reveals.forEach(r=> io.observe(r));

/* SIMPLE AUTH (localStorage/sessionStorage) */
const ACC_KEY = 'mh_demo_accounts_v2';
const OTP_STORAGE_KEY = 'mh_otp_storage';
const INSTITUTIONAL_EMAIL_DOMAIN = '@bl.students.amrita.edu';

function loadAccounts(){ try{ return JSON.parse(localStorage.getItem(ACC_KEY)||'[]'); }catch(e){ return []; } }
function saveAccounts(a){ localStorage.setItem(ACC_KEY, JSON.stringify(a)); }
function setCurrentUser(u){ 
  sessionStorage.setItem('mh_current', JSON.stringify(u)); 
  document.getElementById('loginBtn').classList.add('hidden'); 
  document.getElementById('profileBtn').classList.remove('hidden'); 
  document.getElementById('profileEmail').innerText = u.email; 
  document.getElementById('profileName').value = u.name || ''; 
  // update UI gates (chat/share/contact) when user logs in
  try{ updateAuthGates(); }catch(e){}
  try{ updateAdminUI(); }catch(e){}
}
function getCurrentUser(){ try{ return JSON.parse(sessionStorage.getItem('mh_current')||'null'); }catch(e){ return null; } }
// Returns the effective logged-in user (Firebase user if present, otherwise sessionStorage user)
function getEffectiveUser(){
  try{
    if(window._firebase && window._firebase.auth && window._firebase.auth.currentUser){
      const fbUser = window._firebase.auth.currentUser;
      return { uid: fbUser.uid, email: fbUser.email, name: fbUser.displayName || (fbUser.email||'').split('@')[0] };
    }
    return JSON.parse(sessionStorage.getItem('mh_current')||'null');
  }catch(e){ return null; }
}
function logout(showAlert){ 
  sessionStorage.removeItem('mh_current'); 
  document.getElementById('profileBtn').classList.add('hidden'); 
  document.getElementById('loginBtn').classList.remove('hidden'); 
  if(showAlert) alert('âœ… Logged out successfully'); 
  try{ updateAuthGates(); }catch(e){}
  try{ updateAdminUI(); }catch(e){}
}

/* --- UI gating: enable/disable sections based on login state --- */
function updateAuthGates(){
  const user = getEffectiveUser();
  const logged = !!user;
  console.log('[DEBUG] updateAuthGates - session user:', user, 'firebaseUser:', (window._firebase && window._firebase.auth && window._firebase.auth.currentUser) || null);

  // Chat controls â€” keep accessible but intercept interactions when not logged in
  const messageInput = document.getElementById('messageInput');
  const sendBtn = document.getElementById('sendBtn');
  const clearChatBtn = document.getElementById('clearChatBtn');
      if(messageInput){
        messageInput.placeholder = logged ? 'Type a message...' : 'Sign in to participate in chat';
        // allow users to read the chat even when not signed in, but prevent typing
        messageInput.disabled = !logged;
  }
  // helper to add a click interceptor that opens auth when not logged
      function addClickInterceptor(el){
        if(!el || el._authClickInterceptor) return;
        el.addEventListener('click', (e)=>{
          // Instead of force-opening the auth modal, show a non-blocking toast prompting login
          if(!getEffectiveUser()){
            e.preventDefault();
            showToast('Please sign in to send messages', 'Login', ()=> openAuth('login'));
          }
        });
        el._authClickInterceptor = true;
      }
  if(sendBtn){
        sendBtn.title = logged ? '' : 'Login to send messages';
        // keep the button clickable so users can see the toast prompting them to sign in
        addClickInterceptor(sendBtn);
  }
  if(clearChatBtn){
    clearChatBtn.title = logged ? '' : 'Login to clear messages';
    // if logged in, ensure clearAllChats still works
      if(!clearChatBtn._clearHandler){
      clearChatBtn.addEventListener('click', (e)=>{ if(getEffectiveUser()){ clearAllChats(); } });
      clearChatBtn._clearHandler = true;
    }
    addClickInterceptor(clearChatBtn);
  }

  // Share experience controls
  const shareSend = document.getElementById('shareSend');
  const shareMessage = document.getElementById('shareMessage');
  const shareFile = document.getElementById('shareFile');
  const uploadLabel = document.getElementById('uploadLabel');
  if(shareMessage) {
    // focusing while logged out prompts login
    if(!shareMessage._authInterceptor){
      shareMessage.addEventListener('focus', ()=>{ if(!getEffectiveUser()) showToast('Please sign in to share your experience', 'Login', ()=> openAuth('login')); });
      shareMessage._authInterceptor = true;
    }
  }
  if(shareFile){
    // clicking file chooser should prompt login when not logged
    if(!uploadLabel._authInterceptor){
      uploadLabel.addEventListener('click', (e)=>{ if(!getEffectiveUser()){ e.preventDefault(); showToast('Please sign in to upload files', 'Login', ()=> openAuth('login')); } });
      uploadLabel._authInterceptor = true;
    }
  }
  if(shareSend){
    shareSend.title = logged ? '' : 'Login to share your experience';
    addClickInterceptor(shareSend);
  }

  // Contact form controls (Reach Out For Help)
  const contactForm = document.getElementById('contactForm');
  if(contactForm){
    const emailInput = contactForm.querySelector('input[name="email"]');
    
    // Function to update contact form with user info
    function updateContactFormWithUser(){
    const user = getEffectiveUser();
      if(user && user.email){
        emailInput.value = user.email;
        // Use readOnly instead of disabled so FormData includes the email when submitting
        emailInput.readOnly = true;
        emailInput.style.opacity = '0.85';
        emailInput.style.cursor = 'not-allowed';
        emailInput.title = 'Email locked from your logged-in account';
      } else {
        emailInput.value = '';
        emailInput.readOnly = false;
        emailInput.style.opacity = '';
        emailInput.style.cursor = '';
        emailInput.title = '';
      }
    }
    
    // Update on page load
    updateContactFormWithUser();
    
    // Update when user interaction happens
    contactForm.addEventListener('focusin', updateContactFormWithUser);
    
    // Also bind to auth state changes
    window.addEventListener('loginSuccess', updateContactFormWithUser);
    window.addEventListener('logoutSuccess', updateContactFormWithUser);
    
    // Intercept submit button
    Array.from(contactForm.elements).forEach(el=>{
      const tag = el.tagName;
      if(tag === 'BUTTON' && el.type === 'submit'){
          if(!el._authSubmitInterceptor){
          el.addEventListener('click', (e)=>{ 
            if(!getEffectiveUser()){ 
              e.preventDefault(); 
              showToast('Please sign in to submit the contact form', 'Login', ()=> openAuth('login'));
            } 
          });
          el._authSubmitInterceptor = true;
        }
      }
    });
  }
}

// Simple toast helper for non-blocking popups
function showToast(text, actionLabel, actionFn){
  try{
    let container = document.getElementById('mh_toast_container');
    if(!container){ container = document.createElement('div'); container.id = 'mh_toast_container'; container.style.position = 'fixed'; container.style.right = '16px'; container.style.bottom = '24px'; container.style.zIndex = 10002; container.style.display = 'flex'; container.style.flexDirection = 'column'; container.style.gap = '8px'; document.body.appendChild(container); }
    const t = document.createElement('div');
    t.className = 'mh_toast';
    t.style.background = '#111827'; t.style.color = '#fff'; t.style.padding = '10px 12px'; t.style.borderRadius = '10px'; t.style.boxShadow = '0 6px 24px rgba(2,6,23,0.3)'; t.style.display = 'flex'; t.style.alignItems = 'center'; t.style.gap = '8px'; t.style.minWidth = '220px';
    const span = document.createElement('div'); span.textContent = text; span.style.flex = '1'; span.style.fontSize = '13px';
    t.appendChild(span);
    if(actionLabel && typeof actionFn === 'function'){
      const btn = document.createElement('button'); btn.textContent = actionLabel; btn.style.background = '#4f46e5'; btn.style.color = '#fff'; btn.style.border = 'none'; btn.style.padding = '6px 8px'; btn.style.borderRadius = '6px'; btn.style.cursor = 'pointer'; btn.addEventListener('click', ()=>{ try{ actionFn(); }catch(e){} try{ t.remove(); }catch(e){} }); t.appendChild(btn);
    }
    container.appendChild(t);
    setTimeout(()=>{ try{ t.remove(); }catch(e){} }, 6000);
  }catch(e){ console.warn('showToast failed', e); }
}

/* Email validation for institutional email */
function validateInstitutionalEmail(email){
  if(!email) return false;
  const normalized = email.trim().toLowerCase();
  return normalized.endsWith(INSTITUTIONAL_EMAIL_DOMAIN);
}

/* OTP generation and storage */
function generateOTP(){
  return Math.floor(100000 + Math.random() * 900000).toString();
}

function storeOTP(email, otp){
  const otps = JSON.parse(localStorage.getItem(OTP_STORAGE_KEY) || '{}');
  otps[email] = { code: otp, timestamp: Date.now(), attempts: 0 };
  localStorage.setItem(OTP_STORAGE_KEY, JSON.stringify(otps));
}

function verifyOTP(email, inputOTP){
  const otps = JSON.parse(localStorage.getItem(OTP_STORAGE_KEY) || '{}');
  const stored = otps[email];
  if(!stored) return { valid: false, message: 'No OTP found. Please request a new one.' };
  
  // Check if OTP expired (10 minutes)
  const now = Date.now();
  const expiry = 10 * 60 * 1000; // 10 minutes
  if(now - stored.timestamp > expiry){
    delete otps[email];
    localStorage.setItem(OTP_STORAGE_KEY, JSON.stringify(otps));
    return { valid: false, message: 'OTP expired. Please request a new one.' };
  }
  
  // Check attempts (max 5)
  if(stored.attempts >= 5){
    delete otps[email];
    localStorage.setItem(OTP_STORAGE_KEY, JSON.stringify(otps));
    return { valid: false, message: 'Too many failed attempts. Please request a new OTP.' };
  }
  
  if(stored.code === inputOTP){
    delete otps[email];
    localStorage.setItem(OTP_STORAGE_KEY, JSON.stringify(otps));
    return { valid: true, message: 'OTP verified successfully!' };
  } else {
    stored.attempts++;
    otps[email] = stored;
    localStorage.setItem(OTP_STORAGE_KEY, JSON.stringify(otps));
    return { valid: false, message: `Incorrect OTP. ${5 - stored.attempts} attempts remaining.` };
  }
}

/* AUTH MODAL UI */
const authOverlay = document.getElementById('authOverlay');
const loginForm = document.getElementById('loginForm');
const signupForm = document.getElementById('signupForm');
const otpForm = document.getElementById('otpForm');
const showSignup = document.getElementById('showSignup');
const showLogin = document.getElementById('showLogin');
const sendOtpBtn = document.getElementById('sendOtpBtn');
const otpTarget = document.getElementById('otpTarget');
const verifyOtpBtn = document.getElementById('verifyOtpBtn');
const resendOtpBtn = document.getElementById('resendOtpBtn');

let pendingSignup = null;

function openAuth(mode='login'){
  authOverlay.classList.remove('hidden');
  if(mode==='login'){ loginForm.classList.remove('hidden'); signupForm.classList.add('hidden'); otpForm.classList.add('hidden'); document.getElementById('authTitle').innerText='Login'; }
  if(mode==='signup'){ signupForm.classList.remove('hidden'); loginForm.classList.add('hidden'); otpForm.classList.add('hidden'); document.getElementById('authTitle').innerText='Create account'; }
  if(mode==='otp'){ otpForm.classList.remove('hidden'); loginForm.classList.add('hidden'); signupForm.classList.add('hidden'); document.getElementById('authTitle').innerText='Verify OTP'; }
}
function closeAuth(){ authOverlay.classList.add('hidden'); }

document.getElementById('loginBtn').addEventListener('click', ()=> openAuth('login'));
showSignup.addEventListener('click', ()=> openAuth('signup'));
showLogin.addEventListener('click', ()=> openAuth('login'));
document.getElementById('closeAuth').addEventListener('click', closeAuth);
authOverlay.addEventListener('click', e=> { if(e.target===authOverlay) closeAuth(); });

/* LOGIN */
loginForm.addEventListener('submit', e=>{ if(window._useFirebaseAuth) return;
  e.preventDefault();
  const email = document.getElementById('loginEmail').value.trim().toLowerCase();
  const pwd = document.getElementById('loginPassword').value;
  
  // Validate institutional email
  if(!validateInstitutionalEmail(email)){
    alert('âŒ Please use your institutional email (@bl.students.amrita.edu)');
    return;
  }
  
  if(!pwd || pwd.length < 6){
    alert('âŒ Password must be at least 6 characters');
    return;
  }

  // Check banned users
  const banned = JSON.parse(localStorage.getItem(BANNED_STORAGE_KEY) || '[]');
  if(banned.includes(email)){
    alert('âŒ This account has been banned. Please contact support.');
    return;
  }
  
  const accs = loadAccounts();
  const user = accs.find(a=>a.email===email && a.password===pwd && a.verified);
  if(!user){ 
    alert('âŒ Wrong credentials or unverified account. Please check your email and password.'); 
    return; 
  }
  setCurrentUser(user);
  alert('âœ… Login successful!');
  closeAuth();
  
  // Start Firestore listener (Firestore-only chat)
  try{ if(typeof startChatListener === 'function') startChatListener(); }catch(e){ console.debug('startChatListener not available on login', e); }
});

/* SIGNUP SEND OTP */
sendOtpBtn.addEventListener('click', ()=>{ if(window._useFirebaseAuth) return;
  const name = document.getElementById('signupName').value.trim();
  const email = document.getElementById('signupEmail').value.trim().toLowerCase();
  const pwd = document.getElementById('signupPassword').value;
  
  if(!name || name.length < 2){
    alert('âŒ Please enter a valid name (at least 2 characters)');
    return;
  }
  
  // Strict email validation - must end with @bl.students.amrita.edu
  if(!email.endsWith('@bl.students.amrita.edu')){
    alert('âŒ Please use your institutional email ending with @bl.students.amrita.edu');
    return;
  }
  
  if(!pwd || pwd.length < 6){
    alert('âŒ Password must be at least 6 characters long');
    return;
  }
  
  // Check if account already exists
  const accs = loadAccounts();
  if(accs.some(a=>a.email===email)){
    alert('âŒ Account already exists. Please login instead.');
    openAuth('login');
    return;
  }
  
  // Generate and store OTP
  const otp = generateOTP();
  storeOTP(email, otp);
  pendingSignup = { name, email, password: pwd };
  otpTarget.innerText = email;
  openAuth('otp');
  
  // Simulate OTP sending (in production, this would send via email)
  alert(`ðŸ“¨ OTP sent to ${email}\n\nSimulated OTP: ${otp}\n(In production, this would be sent via email)`);
});

verifyOtpBtn.addEventListener('click', ()=>{ if(window._useFirebaseAuth) return;
  const code = document.getElementById('otpInput').value.trim();
  if(!pendingSignup) {
    alert('âŒ No signup in progress. Please start the signup process again.');
    return;
  }
  
  if(!code || code.length !== 6){
    alert('âŒ Please enter a valid 6-digit OTP');
    return;
  }
  
  const result = verifyOTP(pendingSignup.email, code);
  if(!result.valid){
    alert(`âŒ ${result.message}`);
    return;
  }
  
  // Create account
  const accs = loadAccounts();
  const newAcc = { 
    name: pendingSignup.name, 
    email: pendingSignup.email, 
    password: pendingSignup.password, 
    verified: true,
    createdAt: new Date().toISOString()
  };
  accs.push(newAcc); 
  saveAccounts(accs);
  
  pendingSignup = null;
  document.getElementById('otpInput').value = '';
  alert('âœ… Account created and verified successfully! Logged in.');
  setCurrentUser(newAcc);
  closeAuth();
  
  // Start Firestore listener (Firestore-only chat)
  try{ if(typeof startChatListener === 'function') startChatListener(); }catch(e){ console.debug('startChatListener not available after signup', e); }
});

resendOtpBtn.addEventListener('click', ()=> { if(window._useFirebaseAuth) return; 
  if(!pendingSignup) {
    alert('âŒ No signup in progress.');
    return;
  }
  
  const otp = generateOTP();
  storeOTP(pendingSignup.email, otp);
  alert(`ðŸ“¨ OTP resent to ${pendingSignup.email}\n\nSimulated OTP: ${otp}\n(In production, this would be sent via email)`);
});

/* PROFILE */
const profileOverlay = document.getElementById('profileOverlay');
const profileBtn = document.getElementById('profileBtn');
const closeProfile = document.getElementById('closeProfile');
const profileName = document.getElementById('profileName');
const updateNameBtn = document.getElementById('updateNameBtn');
const changePasswordBtn = document.getElementById('changePasswordBtn');
const logoutBtn = document.getElementById('logoutBtn');

profileBtn.addEventListener('click', ()=> profileOverlay.classList.remove('hidden'));
closeProfile.addEventListener('click', ()=> profileOverlay.classList.add('hidden'));
logoutBtn.addEventListener('click', async ()=> { try{ if(window._firebase && window._firebase.auth){ await window._firebase.auth.signOut(); } }catch(e){} logout(true); profileOverlay.classList.add('hidden'); });

updateNameBtn.addEventListener('click', ()=>{
  const u = getEffectiveUser(); 
  if(!u) return alert('âŒ No user logged in');
  
  const newName = profileName.value.trim(); 
  if(!newName || newName.length < 2) {
    alert('âŒ Please enter a valid name (at least 2 characters)');
    return;
  }
  
  // Generate OTP for name change
  // If Firebase is enabled, use server OTP flow + update Firebase profile
  if(window._useFirebaseAuth && window._firebase && window._firebase.auth){
    (async ()=>{
      try{
        // Request OTP via server
        const resp = await fetch('/api/send-otp', { method:'POST', headers:{ 'content-type':'application/json' }, body: JSON.stringify({ email: u.email, name: u.name || '' }) });
        const j = await resp.json();
        if(!resp.ok){ console.error('send-otp failed', j); return alert('Failed to send OTP: '+(j.error||j.detail||'server error')); }
        const otp = prompt(`ðŸ“¨ Enter the 6-digit OTP sent to ${u.email}`);
        if(!otp) return;
        const verify = await fetch('/api/verify-otp', { method:'POST', headers:{ 'content-type':'application/json' }, body: JSON.stringify({ token: j.token, otp }) });
        const vj = await verify.json();
        if(!verify.ok){ console.error('verify-otp failed', vj); return alert('OTP verification failed: '+(vj.error||'invalid')); }

        // Update Firebase profile (dynamic import to access modular helpers)
        const auth = window._firebase.auth;
        const user = auth.currentUser;
        if(!user) return alert('No Firebase user currently signed in');
        const m = await import('https://www.gstatic.com/firebasejs/12.5.0/firebase-auth.js');
        await m.updateProfile(user, { displayName: newName });

        // Also update Firestore users doc if available
        if(window._firebase.db){
          try{
            const fmod = await import('https://www.gstatic.com/firebasejs/12.5.0/firebase-firestore.js');
            const docRef = fmod.doc(window._firebase.db, 'users', user.uid);
            await fmod.setDoc(docRef, { name: newName }, { merge: true });
          }catch(e){ console.warn('Failed to update users doc', e); }
        }

        // Update UI/session
        setCurrentUser({ uid: user.uid, email: user.email, name: newName });
        alert('âœ… Name updated successfully!');
      }catch(err){ console.error('updateName (firebase) failed', err); alert('Failed to update name: '+err.message); }
    })();
    return;
  }

  // Fallback: local/demo OTP flow
  const otp = generateOTP();
  storeOTP(u.email, otp);
  const code = prompt(`ðŸ“¨ OTP sent to ${u.email}\n\nSimulated OTP: ${otp}\n\nEnter OTP to confirm name change:`);
  
  if(!code){
    return;
  }
  
  const result = verifyOTP(u.email, code);
  if(!result.valid){
    alert(`âŒ ${result.message}`);
    return;
  }
  
  const accs = loadAccounts(); 
  const idx = accs.findIndex(a=>a.email===u.email); 
  if(idx>=0){ 
    accs[idx].name = newName; 
    saveAccounts(accs); 
    setCurrentUser(accs[idx]); 
    alert('âœ… Name updated successfully!');
  }
});

changePasswordBtn.addEventListener('click', ()=>{
  const u = getEffectiveUser(); 
  if(!u) return alert('âŒ No user logged in');
  
  const currentPwd = prompt('Enter your current password:');
  if(!currentPwd) return;
  
  // Verify current password
  // If Firebase is enabled, use server OTP + Firebase updatePassword flow
  if(window._useFirebaseAuth && window._firebase && window._firebase.auth){
    (async ()=>{
      try{
        // Request OTP via server
        const resp = await fetch('/api/send-otp', { method:'POST', headers:{ 'content-type':'application/json' }, body: JSON.stringify({ email: u.email, name: u.name || '' }) });
        const j = await resp.json();
        if(!resp.ok){ console.error('send-otp failed', j); return alert('Failed to send OTP: '+(j.error||j.detail||'server error')); }
        const otp = prompt(`ðŸ“¨ Enter the 6-digit OTP sent to ${u.email}`);
        if(!otp) return;
        const verify = await fetch('/api/verify-otp', { method:'POST', headers:{ 'content-type':'application/json' }, body: JSON.stringify({ token: j.token, otp }) });
        const vj = await verify.json();
        if(!verify.ok){ console.error('verify-otp failed', vj); return alert('OTP verification failed: '+(vj.error||'invalid')); }

        // Ask for new password
        const np = prompt('Enter new password (min 6 characters):');
        if(!np || np.length < 6) return alert('Password must be at least 6 characters long');

        const auth = window._firebase.auth;
        const user = auth.currentUser;
        if(!user) return alert('No Firebase user currently signed in');

        // Try to update password directly
        try{
          const m = await import('https://www.gstatic.com/firebasejs/12.5.0/firebase-auth.js');
          await m.updatePassword(user, np);
          alert('âœ… Password changed successfully!');
        }catch(upErr){
          console.warn('updatePassword failed, attempting reauth if necessary', upErr);
          // If requires recent login, ask current password to reauthenticate
          try{
            const m = await import('https://www.gstatic.com/firebasejs/12.5.0/firebase-auth.js');
            if(upErr.code === 'auth/requires-recent-login' || upErr.code === 'auth/requires-recent-login'){
              const cur = prompt('For security, re-enter your current password to confirm:');
              if(!cur) return alert('Reauthentication cancelled');
              const cred = m.EmailAuthProvider.credential(user.email, cur);
              await m.reauthenticateWithCredential(user, cred);
              await m.updatePassword(user, np);
              alert('âœ… Password changed successfully after reauthentication');
            } else {
              console.error('Password update error', upErr);
              alert('Failed to update password: '+(upErr.message||upErr));
            }
          }catch(reauthErr){ console.error('Reauth/update failed', reauthErr); alert('Failed to update password: '+(reauthErr.message||reauthErr)); }
        }
      }catch(err){ console.error('changePassword (firebase) failed', err); alert('Failed to change password: '+err.message); }
    })();
    return;
  }

  // Local/demo flow
  const accs = loadAccounts();
  const user = accs.find(a=>a.email===u.email && a.password===currentPwd);
  if(!user){
    alert('âŒ Current password is incorrect');
    return;
  }
  
  const np = prompt('Enter new password (min 6 characters):');
  if(!np || np.length < 6){
    alert('âŒ Password must be at least 6 characters long');
    return;
  }
  
  // Generate OTP for password change
  const otp = generateOTP();
  storeOTP(u.email, otp);
  const code = prompt(`ðŸ“¨ OTP sent to ${u.email}\n\nSimulated OTP: ${otp}\n\nEnter OTP to confirm password change:`);
  
  if(!code){
    return;
  }
  
  const result = verifyOTP(u.email, code);
  if(!result.valid){
    alert(`âŒ ${result.message}`);
    return;
  }
  
  const idx = accs.findIndex(a=>a.email===u.email);
  if(idx>=0){ 
    accs[idx].password = np; 
    saveAccounts(accs); 
    alert('âœ… Password changed successfully!');
  }
});

/* restore session on load */
window.addEventListener('load', ()=>{ 
  const cur = getEffectiveUser(); 
  if(cur){ 
    document.getElementById('loginBtn').classList.add('hidden'); 
    profileBtn.classList.remove('hidden'); 
    document.getElementById('profileEmail').innerText = cur.email; 
    profileName.value = cur.name || ''; 
  }
  // Start Firestore listener (Firestore-only chat)
  try{ if(typeof startChatListener === 'function') startChatListener(); }catch(e){ console.debug('startChatListener not available at load', e); }
  
  // Add email validation on input
  const signupEmailInput = document.getElementById('signupEmail');
  const loginEmailInput = document.getElementById('loginEmail');
  
  if(signupEmailInput){
    signupEmailInput.addEventListener('blur', function(){
      const email = this.value.trim().toLowerCase();
      if(email && !validateInstitutionalEmail(email)){
        this.style.borderColor = '#ef4444';
        this.style.boxShadow = '0 0 0 3px rgba(239, 68, 68, 0.1)';
      } else {
        this.style.borderColor = '';
        this.style.boxShadow = '';
      }
    });
  }
  
  if(loginEmailInput){
    loginEmailInput.addEventListener('blur', function(){
      const email = this.value.trim().toLowerCase();
      if(email && !validateInstitutionalEmail(email)){
        this.style.borderColor = '#ef4444';
        this.style.boxShadow = '0 0 0 3px rgba(239, 68, 68, 0.1)';
      } else {
        this.style.borderColor = '';
        this.style.boxShadow = '';
      }
    });
  }
  // Ensure gated UI reflects session state
  try{ updateAuthGates(); }catch(e){}
});

/* VIDEO GALLERY - pixel-based loop + autoplay + overlay controls + indicators */
(function(){
  const track = document.getElementById('galleryTrack');
  const slidesOrig = Array.from(track.children);
  if(!slidesOrig.length) return;
  const N = slidesOrig.length;
  // clone
  const firstClone = slidesOrig[0].cloneNode(true);
  const lastClone = slidesOrig[N-1].cloneNode(true);
  firstClone.classList.add('clone'); lastClone.classList.add('clone');
  track.insertBefore(lastClone, track.firstChild);
  track.appendChild(firstClone);

  let idx = 0, anim=false;
  const fade = document.getElementById('galleryFade');
  const viewport = document.getElementById('galleryViewport');

  // Hide viewport until positioned to avoid showing last-clone first
  if(viewport) viewport.style.visibility = 'hidden';

  // Dynamic container sizing based on content
  function updateContainerSize(){
    const children = Array.from(track.children);
    const currentIdx = idx + 1;
    const currentSlide = children[currentIdx];
    if(!currentSlide) return;
    
    // Prefer a fixed 16:9 aspect for iframes
    const iframe = currentSlide.querySelector('iframe.yt-embed');
    const viewportWidth = track.parentElement.getBoundingClientRect().width;
    if(iframe){
      const calculatedHeight = Math.round((9/16) * viewportWidth);
      viewport.style.height = calculatedHeight + 'px';
      viewport.style.minHeight = calculatedHeight + 'px';
      return;
    }
    
    // Fallback: if using <video>
    const video = currentSlide.querySelector('video');
    if(video){
      const setByMeta = ()=>{
        const vw = video.videoWidth, vh = video.videoHeight;
        if(vw && vh){
          const ar = vw / vh;
          const h = Math.round(viewportWidth / ar);
          viewport.style.height = h + 'px';
          viewport.style.minHeight = h + 'px';
        }
      };
      if(video.readyState >= 1){ setByMeta(); }
      else { video.onloadedmetadata = setByMeta; }
    }
  }

  function slideWidth(){ return track.parentElement.getBoundingClientRect().width; }
  function setPos(i){ const w=slideWidth(); track.style.transition='none'; track.style.transform = `translateX(-${(i+1)*w}px)`; }

  // play visible â€” for iframe embeds, do nothing; for <video>, try to play
  function playVisible(){
    const children = Array.from(track.children);
    const currentIdx = idx + 1;
    
    children.forEach((child, i) => {
      const iframe = child.querySelector('iframe.yt-embed');
      const v = child.querySelector('video');
      
      // Do not alter iframe src; YouTube handles playback on user click
      if(iframe){ /* no-op */ }
      
      // Handle regular video elements (fallback)
      if(!v) return;
      
      try {
        if(i === currentIdx){
          v.muted = true;
          v.currentTime = 0;
          
          const attemptPlay = () => {
            const playPromise = v.play();
            if(playPromise !== undefined){
              playPromise
                .then(() => {
                  console.log('Video playing successfully');
                  updateContainerSize();
                })
                .catch(err => {
                  console.log('Play failed, retrying...', err);
                  setTimeout(() => {
                    v.play().catch(e => console.log('Final play attempt failed'));
                  }, 100);
                });
            }
          };
          
          attemptPlay();
        } else {
          v.pause();
          v.currentTime = 0;
        }
      } catch(e) {
        console.log('Video control error:', e);
      }
    });
  }

  function goTo(target){
    if(anim) return;
    anim = true; 
    fade.classList.add('active');
    const w = slideWidth();
    const visual = target + 1;
    track.style.transition = 'transform .48s cubic-bezier(.2,.9,.12,1)';
    track.style.transform = `translateX(-${visual * w}px)`;
    
    // pause all videos
    Array.from(track.querySelectorAll('video')).forEach(v=>{ 
      try{ v.pause(); v.currentTime = 0; }catch(e){} 
    });
    
    const onEnd = ()=> {
      track.removeEventListener('transitionend', onEnd);
      if(visual === 0){ 
        track.style.transition='none'; 
        track.style.transform = `translateX(-${N * w}px)`; 
        target = N - 1; 
      }
      else if(visual === N + 1){ 
        track.style.transition='none'; 
        track.style.transform = `translateX(-${1 * w}px)`; 
        target = 0; 
      }
      idx = (target + N) % N;
      updateContainerSize();
      fade.classList.remove('active');
      
      setTimeout(()=>{ 
        anim=false;
        // Update height after animation
        updateContainerSize();
        setTimeout(updateContainerSize, 80);
      }, 30);
    };
    track.addEventListener('transitionend', onEnd);
  }

  // bind arrows
  document.getElementById('nextVideo').addEventListener('click', ()=> goTo(idx+1));
  document.getElementById('prevVideo').addEventListener('click', ()=> goTo(idx-1));

  // overlays: play/pause, mute
  function bindOverlays(){
    const slidesAll = track.querySelectorAll('.video-slide');
    slidesAll.forEach(sl=>{
      const btnPlay = sl.querySelector('[data-action="playpause"]');
      const btnMute = sl.querySelector('[data-action="mute"]');
      const v = sl.querySelector('video');
      if(!v) return;
      let tTO = null;
      sl.addEventListener('touchstart', ()=>{ sl.classList.add('touch-active'); clearTimeout(tTO); tTO = setTimeout(()=> sl.classList.remove('touch-active'), 3000); });

      // Play / Pause
      btnPlay.addEventListener('click', (ev)=>{ ev.stopPropagation(); if(v.paused){ v.play().catch(()=>{}); btnPlay.textContent='âšâš'; } else { v.pause(); btnPlay.textContent='â–¶ï¸Ž'; } });
      // Mute / Unmute
      btnMute.addEventListener('click', (ev)=>{ ev.stopPropagation(); v.muted = !v.muted; btnMute.textContent = v.muted ? 'ðŸ”‡' : 'ðŸ”Š'; });

      v.addEventListener('play', ()=> btnPlay.textContent='âšâš');
      v.addEventListener('pause', ()=> btnPlay.textContent='â–¶ï¸Ž');
      // if a user pauses, we won't auto-advance until play finishes naturally again
    });
  }

  // bind ended to children 1..N + auto-play after user pause ends
  function bindEnded(){
    const children = Array.from(track.children);
    for(let i=1; i<=N; i++){
      const v = children[i].querySelector('video'); 
      if(!v) continue;
      
      // Clear old listeners to prevent duplicates
      v.onended = null;
      
      // When video ends, go to next slide
      v.addEventListener('ended', ()=> { 
        if(idx === (i-1)){
          goTo(((i-1)+1) % N); 
        }
      });
      
      // Update container size when video starts playing
      v.addEventListener('play', ()=> {
        if(idx === (i-1)){
          updateContainerSize();
        }
      });
      
      // Update container size when metadata loads
      v.addEventListener('loadedmetadata', ()=> {
        if(idx === (i-1)){
          updateContainerSize();
        }
      });
      
      // Force mute on current video
      if(idx === (i-1)){
        v.muted = true;
      }
    }
  }

  // swipe
  (function(){ let sx=0; const view = track.parentElement; view.addEventListener('touchstart', e=> sx = e.touches[0].clientX); view.addEventListener('touchend', e=> { const diff = e.changedTouches[0].clientX - sx; if(diff>50) goTo(idx-1); if(diff<-50) goTo(idx+1); }); })();

  // keyboard
  window.addEventListener('keydown', e=> { if(['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return; if(e.key==='ArrowLeft') goTo(idx-1); if(e.key==='ArrowRight') goTo(idx+1); });

  // init on load
  window.addEventListener('load', ()=> {
    setTimeout(()=>{ 
      setPos(0); 
      bindOverlays(); 
      bindEnded(); 
      updateContainerSize(); 
      if(viewport) viewport.style.visibility = 'visible';
    }, 120);
  });
  window.addEventListener('resize', ()=> { setPos(idx); updateContainerSize(); });
})();

/* STORIES: simple scroll (auto-scroll removed) */
// No JS carousel; native horizontal scroll + scroll-snap now handles interaction.

/* SHARE / CONTACT / CHAT */
/* keep file name display responsive and add small animation on change */
const shareFileInput = document.getElementById('shareFile');
const fileNameEl = document.getElementById('fileName');
const uploadLabel = document.getElementById('uploadLabel');

shareFileInput.addEventListener('change', e=> {
  const f = e.target.files[0];
  fileNameEl.textContent = f ? f.name : 'No file chosen';
  // subtle animation feedback when a file is chosen
  if(f){
    uploadLabel.animate([{ transform: 'translateY(0)' }, { transform: 'translateY(-3px)' }, { transform: 'translateY(0)' }], { duration: 260, easing: 'ease-out' });
  }
});

/* SHARE EXPERIENCE */
document.getElementById('shareSend').addEventListener('click', async ()=> { 
  // Use unified effective user (Firebase or session) to decide login state
  const user = getEffectiveUser();
  if(!user){
    alert('Please login to share your experience');
    openAuth('login');
    return;
  }
  
  const t = document.getElementById('shareMessage').value.trim(); 
  if(!t) {
    alert('Please write a message.');
    return;
  }
  
  const file = document.getElementById('shareFile').files[0];
  let uploadedUrl = null;

  let uploadFailed = false;
  if(file){
    // Upload to Cloudinary using server-signed request
    try{
      const uploadResult = await uploadFileToCloudinarySigned(file);
      uploadedUrl = uploadResult.secure_url || uploadResult.url || uploadResult.secureUrl || null;
      if(!uploadedUrl){
        throw new Error('No URL returned from Cloudinary');
      }
    }catch(err){
      console.error('Cloudinary upload failed:', err);
      // Ask the user whether to proceed without the file. If user cancels, abort the share.
      const proceed = confirm('File upload failed: ' + (err && err.message ? err.message : String(err)) + '\n\nDo you want to share the message without the file? Click OK to continue, Cancel to abort.');
      if(!proceed){
        if(fileNameEl) fileNameEl.textContent = 'No file chosen';
        return; // abort sharing
      }
      uploadedUrl = null;
      uploadFailed = true;
    }
  }

  const fileInfo = uploadedUrl ? `\nâœ… File uploaded successfully` : (file ? `\nFile: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB) - not uploaded` : '');

  // Store shared experiences (optional)
  const shares = JSON.parse(localStorage.getItem('mh_shared_experiences') || '[]');
  const shareObj = {
    user: user.name || user.email,
    email: user.email,
    message: t,
    fileName: file ? file.name : null,
    fileUrl: uploadedUrl,
    timestamp: Date.now(),
    date: new Date().toISOString()
  };
  shares.push(shareObj);
  localStorage.setItem('mh_shared_experiences', JSON.stringify(shares));

  // If Firebase is enabled, persist share to Firestore and optionally post into chats for realtime visibility
  try{
    if(window._useFirebaseAuth && window._firebase && window._firebase.db){
      const db = window._firebase.db;
      try{ 
        await addDoc(collection(db,'shares'), { ...shareObj, createdAt: serverTimestamp() }); 
      }catch(e){ 
        console.warn('Failed to write share to Firestore', e); 
      }
      // Also post as a chat message so it appears in realtime chat. If Firestore is not available or the write fails,
      // fall back to the server-side /api/messages endpoint so other clients still receive the message.
      const chatPayload = {
        uid: window._firebase.auth && window._firebase.auth.currentUser ? window._firebase.auth.currentUser.uid : null,
        from: user.name || user.email.split('@')[0],
        email: user.email,
        text: `${t}${uploadedUrl ? '\n' + uploadedUrl : ''}`,
        timestamp: Date.now()
      };
      try{
        console.debug('[DEBUG] Firestore write payload (share->chats):', chatPayload);
        await addDoc(collection(db,'chats'), { ...chatPayload, createdAt: serverTimestamp() });
      }catch(e){
        console.warn('Failed to post share into chats (Firestore). Falling back to server /api/messages', e);
        try{
          await fetch('/api/messages', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ from: chatPayload.from, email: chatPayload.email, text: chatPayload.text, timestamp: chatPayload.timestamp }) });
        }catch(err){ console.warn('Server /api/messages fallback failed', err); }
      }
    }
  }catch(e){ console.warn('share persistence error', e); }

  alert(`âœ… Experience shared successfully!${fileInfo}`);
  document.getElementById('shareMessage').value=''; 
  document.getElementById('shareFile').value=''; 
  document.getElementById('fileName').textContent='No file chosen';
});


// Helper: upload file to Cloudinary using server-signed signature
async function uploadFileToCloudinarySigned(file){
  // First, check server config to see if unsigned upload preset is available
  const cfgResp = await fetch('/api/cloudinary-config');
  if(!cfgResp.ok) throw new Error('Cloudinary config request failed');
  const cfg = await cfgResp.json();
  const cloudName = cfg.cloud_name;
  const uploadPreset = cfg.upload_preset;
  const url = `https://api.cloudinary.com/v1_1/${cloudName}/image/upload`;
  // Helper to perform a signed upload when signature data is available
  function doSignedUpload(sigData){
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open('POST', url);
      const fd = new FormData();
      fd.append('file', file);
      fd.append('api_key', sigData.api_key || '');
      fd.append('timestamp', sigData.timestamp || '');
      fd.append('signature', sigData.signature || '');
      fd.append('transformation', 'w_1600,c_limit');

      xhr.upload.onprogress = function(e){ if(e.lengthComputable){ const pct = Math.round((e.loaded / e.total) * 100); if(fileNameEl) fileNameEl.textContent = `Uploading: ${pct}%`; } };
      xhr.onload = function(){
        if(xhr.status >= 200 && xhr.status < 300){
          try{ const resp = JSON.parse(xhr.responseText); if(fileNameEl) fileNameEl.textContent = 'No file chosen'; resolve(resp); }catch(e){ resolve({ url: xhr.responseText }); }
        } else {
          console.error('Signed upload failed:', xhr.status, xhr.statusText, xhr.responseText);
          reject(new Error('Signed upload failed: ' + (xhr.statusText || xhr.status) + ' - ' + xhr.responseText));
        }
      };
      xhr.onerror = function(){ reject(new Error('Upload network error')); };
      xhr.send(fd);
    });
  }

  // If upload_preset is provided, try an unsigned upload first. If that fails (bad request),
  // automatically retry using a server-signed upload (handles presets that are not configured as unsigned).
  if(uploadPreset){
    try{
      const unsignedResp = await new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', url);
        const fd = new FormData();
        fd.append('file', file);
        fd.append('upload_preset', uploadPreset);
        fd.append('transformation', 'w_1600,c_limit');

        xhr.upload.onprogress = function(e){ if(e.lengthComputable){ const pct = Math.round((e.loaded / e.total) * 100); if(fileNameEl) fileNameEl.textContent = `Uploading: ${pct}%`; } };
        xhr.onload = function(){
          if(xhr.status >= 200 && xhr.status < 300){
            try{ const resp = JSON.parse(xhr.responseText); if(fileNameEl) fileNameEl.textContent = 'No file chosen'; resolve(resp); }catch(e){ resolve({ url: xhr.responseText }); }
          } else {
            console.warn('Unsigned upload failed:', xhr.status, xhr.statusText, xhr.responseText);
            reject({ status: xhr.status, statusText: xhr.statusText, body: xhr.responseText });
          }
        };
        xhr.onerror = function(){ reject(new Error('Upload network error')); };
        xhr.send(fd);
      });
      return unsignedResp;
    }catch(unsignedErr){
      // If unsigned upload failed with a Bad Request, attempt signed upload automatically
      console.warn('Unsigned upload failed, attempting server-signed upload', unsignedErr);
      try{
        const sigResp = await fetch('/api/cloudinary-sign', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ filename: file.name }) });
        if(!sigResp.ok) throw new Error('Signature request failed');
        const sigData = await sigResp.json();
        return await doSignedUpload(sigData);
      }catch(signedErr){
        console.error('Signed retry after unsigned failure also failed', signedErr);
        // Server-side fallback: read file as base64 and upload via /api/upload-cloudinary
        try{
          const reader = new FileReader();
          const base64 = await new Promise((resolve, reject) => {
            reader.onload = () => {
              const result = reader.result;
              const base64Str = typeof result === 'string' ? result.split(',')[1] : null;
              if(!base64Str) reject(new Error('Failed to read file'));
              else resolve(base64Str);
            };
            reader.onerror = () => reject(new Error('File read error'));
            reader.readAsDataURL(file);
          });
          console.log('Attempting server-side upload fallback...');
          const serverResp = await fetch('/api/upload-cloudinary', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ filename: file.name, data: base64 }) });
          if(!serverResp.ok) throw new Error('Server upload returned ' + serverResp.status);
          const serverJson = await serverResp.json();
          console.log('Server upload response:', serverJson);
          // Check for URL in various possible fields
          const uploadedUrl = serverJson.secure_url || serverJson.url || serverJson.secureUrl || serverJson.publicUrl || null;
          if(!uploadedUrl) throw new Error('No URL in Cloudinary response: ' + JSON.stringify(serverJson));
          if(fileNameEl) fileNameEl.textContent = 'No file chosen';
          return serverJson;
        }catch(fallbackErr){
          console.error('Server-side fallback failed', fallbackErr);
          throw new Error('All upload methods failed. ' + (signedErr && signedErr.message ? signedErr.message : 'Unknown error'));
        }
      }
    }
  }
  
  // No upload preset provided: perform a signed upload (normal flow)
  const sigResp = await fetch('/api/cloudinary-sign', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ filename: file.name }) });
  if(!sigResp.ok) throw new Error('Signature request failed');
  const sigData = await sigResp.json();
  return await doSignedUpload(sigData);
}

/* CONTACT FORM */
document.getElementById('contactForm').addEventListener('submit', e=> { 
  e.preventDefault();

  // Require user to be logged in before allowing contact submission
  const user = getEffectiveUser();
  if(!user){
    // Show non-blocking toast prompting login
    showToast('Please sign in to submit the contact form', 'Login', ()=> openAuth('login'));
    return;
  }

  const formEl = e.target;
  // Ensure email input is present and not disabled so FormData includes it
  const formData = new FormData(formEl);
  const name = (formData.get('name') || '').trim();
  const email = (formData.get('email') || '').trim().toLowerCase();
  const message = (formData.get('message') || '').trim();

  // Validate required fields
  if(!name || !email || !message){
    alert('âŒ Please fill in all fields');
    return;
  }

  // Basic email format validation
  function isValidEmailAddress(e){ try{ return /^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(String(e).toLowerCase()); }catch(_) { return false; } }
  if(!isValidEmailAddress(email)){
    alert('âŒ Please enter a valid email address');
    return;
  }

  // Store contact submissions locally as backup
  const contacts = JSON.parse(localStorage.getItem('mh_contact_submissions') || '[]');
  contacts.push({ name, email, message, timestamp: Date.now(), date: new Date().toISOString() });
  localStorage.setItem('mh_contact_submissions', JSON.stringify(contacts));

  // Send to FormSubmit via AJAX (FormSubmit supports CORS)
  const statusEl = document.getElementById('contactStatus');
  statusEl.textContent = 'Sending...';

  // Use the configured FormSubmit recipient from the hidden action or env (hardcoded here)
  const endpoint = 'https://formsubmit.co/ajax/singhkrish.np@gmail.com';
  fetch(endpoint, { method: 'POST', body: formData, headers: { 'Accept': 'application/json' } })
    .then(r=>r.json())
    .then(j=>{
      if(j.success){
        statusEl.textContent = 'âœ… Message sent â€” we will get back to you soon.';
        // show popup toast for success
        showToast('Message sent â€” we will get back to you soon.');
        formEl.reset();
        // Refresh contact form prefill after reset
        setTimeout(()=> window.dispatchEvent(new Event('loginSuccess')), 200);
      } else {
        statusEl.textContent = 'âš ï¸ Failed to send email; saved locally.';
        showToast('Failed to send message; saved locally.');
      }
    }).catch(err=>{
      console.error('FormSubmit error', err);
      statusEl.textContent = 'âš ï¸ Network error â€” message saved locally.';
      showToast('Network error â€” message saved locally.');
    });
});

/* CHAT: Real-time chat functionality */
const CHAT_STORAGE_KEY = 'mh_chat_messages';
const REPORTS_STORAGE_KEY = 'mh_reported_chats';
const ADMINS_STORAGE_KEY = 'mh_admins';
const BANNED_STORAGE_KEY = 'mh_banned_users';
const DEFAULT_ADMINS = ['admin@bl.students.amrita.edu'];
let chatMessages = [];

function loadChatHistory(){
  // Chat is Firestore-backed only. Real-time messages are delivered via onSnapshot.
  // This function is intentionally a no-op to avoid localStorage usage.
  console.debug('loadChatHistory: noop (Firestore-only chat)');
}

function saveChatMessage(msg){
  // Firestore-only: attempt to send via Firebase if available; otherwise inform user
  try{
    // If Firebase is available and user is signed in, use the Firebase send handler
    if(window._firebase && window._firebase.auth && window._firebase.auth.currentUser && typeof window.sendChatMessage === 'function'){
      // set input and call the firebase-backed sender
      const input = document.getElementById('messageInput');
      if(input){ input.value = msg.text; }
      try{ window.sendChatMessage(); }catch(e){ console.error('Firebase send failed', e); }
      return;
    }
  }catch(e){ console.warn('saveChatMessage error', e); }
  // If we reach here, Firestore is not available or user not signed in
  alert('Chat requires Firebase sign-in. Please sign in to use realtime chat.');
}

function renderChatMessages(){
  const w = document.getElementById('chatWindow');
  if(!w){
    console.warn('[DEBUG] chatWindow element not found in DOM');
    return;
  }

  // Prefer Firebase-backed messages when available (set on window.chatMessages by the Firebase listener)
  const sourceMsgs = Array.isArray(window.chatMessages) ? window.chatMessages : chatMessages;

  console.log('[DEBUG] renderChatMessages called with', sourceMsgs ? sourceMsgs.length : 0, 'messages');

  // Clear previous content
  w.innerHTML = '';

  if(!sourceMsgs || sourceMsgs.length === 0){
    w.innerHTML = '<div class="text-center text-sm muted py-8">No messages yet. Start the conversation!</div>';
    console.log('[DEBUG] No messages to display');
    return;
  }

  sourceMsgs.forEach(msg => {
    const user = getEffectiveUser();
    const isOwn = user && msg.email === user.email;
    const reported = msg.reported || false;
    const isPending = msg.pending === true;
    const isFailed = msg.failed === true;

    // Create message container
    const container = document.createElement('div');
    container.className = isOwn ? 'chat-message-own' : 'chat-message-other';
    // Add visual indicator for pending/failed
    if(isPending) container.style.opacity = '0.7';
    if(isFailed) container.style.opacity = '0.5'; container.style.borderLeft = '3px solid #ef4444';

    // Create avatar
    const avatar = document.createElement('div');
    avatar.className = 'chat-avatar';
    const initials = (msg.from || '').split(' ').map(s=>s[0]||'').slice(0,2).join('').toUpperCase();
    avatar.textContent = initials || msg.from?.charAt(0)?.toUpperCase() || 'U';

    // Create content wrapper
    const content = document.createElement('div');
    content.className = 'chat-content';

    // Create header (name + time + status)
    const header = document.createElement('div');
    header.className = 'chat-header';
    const statusLabel = isPending ? ' â³ sending...' : (isFailed ? ' âŒ failed' : '');
    header.innerHTML = `<strong>${escapeHtml(msg.from)}</strong> <span class="chat-time">${escapeHtml(msg.ts)}${statusLabel}</span>`;

    // Create message bubble
    const bubble = document.createElement('div');
    bubble.className = isOwn ? 'chat-bubble-own' : 'chat-bubble-other';
    bubble.innerHTML = `<div class="text-sm">${escapeHtml(msg.text)}</div>`;

    // Create actions (report button)
    const actions = document.createElement('div');
    actions.className = 'chat-actions';
    const reportBtn = document.createElement('button');
    reportBtn.type = 'button';
    reportBtn.className = 'report-btn';
    reportBtn.textContent = reported ? 'âœ“ Reported' : 'Report';
    reportBtn.dataset.id = msg.id;
    actions.appendChild(reportBtn);

    // Build content structure
    content.appendChild(header);
    content.appendChild(bubble);
    content.appendChild(actions);

    // Add avatar and content to container
    if(isOwn){
      container.appendChild(content);
      container.appendChild(avatar);
    } else {
      container.appendChild(avatar);
      container.appendChild(content);
    }

    w.appendChild(container);
  });

  // Attach report handlers
    Array.from(w.querySelectorAll('.report-btn')).forEach(b=>{
    b.addEventListener('click', (e)=>{
      e.preventDefault();
      const id = b.dataset.id;
      if(!getEffectiveUser()){ openAuth('login'); return; }
      // prompt for reason
      const reason = prompt('Why are you reporting this message? (optional)');
      if(reason === null) return; // user cancelled
      // If Firebase-backed reporting is present, prefer that implementation (attached to window.reportChat)
      if(window.reportChat && window.reportChat !== reportChat){
        try{ window.reportChat(id, reason); }catch(er){ console.error('window.reportChat failed', er); reportChat(id, reason); }
      } else {
        reportChat(id, reason);
      }
    });
  });

  // Keep scroll at bottom
  w.scrollTop = w.scrollHeight;
}

// Expose renderChatMessages to window for cross-scope access
window.renderChatMessages = renderChatMessages;

function clearAllChats(){
  if(chatMessages.length === 0) return;
  if(confirm('Are you sure you want to clear all chat messages?')){
    chatMessages = [];
    localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify([]));
    renderChatMessages();
  }
}

const sendBtn = document.getElementById('sendBtn');
const messageInput = document.getElementById('messageInput');
const clearChatBtn = document.getElementById('clearChatBtn');

sendBtn.addEventListener('click', ()=>{
  // Prefer Firestore-backed send when Firebase override is available; otherwise use local send
  if(typeof window.sendChatMessage === 'function'){
    try{ window.sendChatMessage(); }catch(e){ console.error('window.sendChatMessage threw', e); }
  } else {
    sendChatMessage();
  }
});

clearChatBtn.addEventListener('click', async ()=>{
  if(!window._firebase || !window._firebase.auth) { clearAllChats(); return; }
  const user = window._firebase.auth.currentUser;
  const isAdmin = user ? await checkIsAdmin(user.uid) : false;
  if(!isAdmin){ alert('Only admins can clear chat.'); return; }
  if(!confirm('Clear all chats? This cannot be undone.')) return;
  // delete all chats from Firestore using v12 modular API
  try{
    const { writeBatch, getDocs, collection, deleteDoc, doc } = window._firebase.db.__firestore || {};
    const db = window._firebase.db;
    // Import writeBatch from module scope (need to use imported function)
    // For now, use the alternative: delete each doc individually or use REST API
    // Since we can't access writeBatch directly, let's iterate and delete
    const chatsRef = collection(db, 'chats');
    const snapshot = await getDocs(chatsRef);
    const batch = writeBatch(db);
    snapshot.docs.forEach(doc => {
      batch.delete(doc.ref);
    });
    await batch.commit();
    alert('Chats cleared');
  }catch(e){ 
    console.error('Clear error:', e); 
    // Fallback: try individual deletes
    try{
      const { getDocs, collection, deleteDoc, doc } = await import("https://www.gstatic.com/firebasejs/12.5.0/firebase-firestore.js");
      const db = window._firebase.db;
      const chatsRef = collection(db, 'chats');
      const snapshot = await getDocs(chatsRef);
      for(const d of snapshot.docs){
        await deleteDoc(d.ref);
      }
      alert('Chats cleared');
    }catch(e2){ console.error(e2); alert('Failed to clear. Check Firestore setup.'); }
  }
});

messageInput.addEventListener('keypress', (e)=>{
  if(e.key === 'Enter' && !e.shiftKey){
    e.preventDefault();
    // Prefer Firestore-backed send when Firebase override is available; otherwise use local send
    if(typeof window.sendChatMessage === 'function'){
      try{ window.sendChatMessage(); }catch(e){ console.error('window.sendChatMessage threw', e); }
    } else {
      sendChatMessage();
    }
  }
});

function sendChatMessage(){
  // Check effective user (Firebase or sessionStorage)
  const eff = getEffectiveUser();
  console.log('[DEBUG] sendChatMessage - effective user:', eff);
  let user = eff;
  
  if(!user){ 
    alert('Please login to send messages');
    openAuth('login'); 
    return;
  }
  // check banned
  const banned = JSON.parse(localStorage.getItem(BANNED_STORAGE_KEY) || '[]');
  if(banned.includes(user.email)){
    alert('Your account has been banned from sending messages.');
    logout();
    return;
  }
  
  const txt = messageInput.value.trim();
  if(!txt) return;
  
  // If Firebase is enabled, send via Firestore; otherwise use localStorage
  if(window._firebase && window._firebase.auth && window._firebase.auth.currentUser && window._firebase.db){
    // Use Firestore-backed sendChatMessage (will be overridden in Firebase module)
    if(window.sendChatMessage && window.sendChatMessage !== sendChatMessage){
      window.sendChatMessage(); // Call the Firebase version
      return;
    }
  }
  
  const msg = {
    from: user.name || user.email.split('@')[0],
    email: user.email,
    text: txt,
    ts: new Date().toLocaleTimeString(),
    timestamp: Date.now()
  };
  
  saveChatMessage(msg);
  messageInput.value = '';
  // Attempt to persist to server messages API so other instances can read it (best-effort)
  try{
    fetch('/api/messages', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(msg) }).then(r=>{ /* ignore result */ }).catch(e=>{ console.debug('Server message persist failed', e); });
  }catch(e){ /* ignore */ }
  
  // Simulate receiving a response (optional - can be removed)
  setTimeout(() => {
    if(Math.random() > 0.7){ // 30% chance of auto-response
      const responses = [
        'Thank you for sharing!',
        'We appreciate your message.',
        'Your message has been received.',
        'Thank you for reaching out!'
      ];
      const autoMsg = {
        from: 'Support Team',
        email: 'support@bl.students.amrita.edu',
        text: responses[Math.floor(Math.random() * responses.length)],
        ts: new Date().toLocaleTimeString(),
        timestamp: Date.now()
      };
      saveChatMessage(autoMsg);
    }
  }, 1000);
}

/* Emoji picker: populate and bind emoji insertion */
(function(){
  const emojiBtn = document.getElementById('emojiBtn');
  const emojiPicker = document.getElementById('emojiPicker');
  const emojiList = document.getElementById('emojiList');
  const input = document.getElementById('messageInput');
  if(!emojiBtn || !emojiPicker || !emojiList || !input) return;

  const emojis = ['ðŸ˜€','ðŸ˜','ðŸ˜‚','ðŸ¤£','ðŸ˜Š','ðŸ˜','ðŸ˜¢','ðŸ˜®','ðŸ˜¡','ðŸ‘','ðŸ‘Ž','ðŸ™','ðŸŽ‰','â¤ï¸','ðŸ”¥','ðŸ˜´','ðŸ¤”','ðŸ™Œ','ðŸ˜…','ðŸ˜‡','ðŸ¤','ðŸ‘','ðŸ¤—','ðŸ˜Ž','ðŸ˜œ','ðŸ˜¬','ðŸ˜•','ðŸ¤©','ðŸ’¯','âœ”ï¸'];
  emojis.forEach(e => {
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'text-xl p-1';
    b.style.border = 'none';
    b.style.background = 'transparent';
    b.textContent = e;
    b.addEventListener('click', (ev)=>{
      ev.preventDefault();
      // require login to insert
      if(!getEffectiveUser()){ openAuth('login'); return; }
      insertAtCursor(input, e);
      emojiPicker.classList.add('hidden');
      input.focus();
    });
    emojiList.appendChild(b);
  });

  emojiBtn.addEventListener('click', (e)=>{
    e.stopPropagation();
    if(!getEffectiveUser()){ openAuth('login'); return; }
    emojiPicker.classList.toggle('hidden');
  });

  // close when clicking outside
  document.addEventListener('click', ()=>{ emojiPicker.classList.add('hidden'); });
  emojiPicker.addEventListener('click', (e)=> e.stopPropagation());

  function insertAtCursor(field, value){
    try{
      const start = field.selectionStart || 0;
      const end = field.selectionEnd || 0;
      const text = field.value || '';
      field.value = text.slice(0,start) + value + text.slice(end);
      const pos = start + value.length;
      field.selectionStart = field.selectionEnd = pos;
    }catch(e){ field.value = (field.value || '') + value; }
  }
})();

/* ----------------- Reporting / Admin / Banning ----------------- */
function getAdmins(){
  try{ const a = JSON.parse(localStorage.getItem(ADMINS_STORAGE_KEY) || 'null'); return Array.isArray(a) && a.length ? a : DEFAULT_ADMINS.slice(); }catch(e){ return DEFAULT_ADMINS.slice(); }
}
function isAdmin(email){ if(!email) return false; return getAdmins().includes(email.toLowerCase()); }

function getBanned(){ try{ return JSON.parse(localStorage.getItem(BANNED_STORAGE_KEY) || '[]'); }catch(e){ return []; } }
function isBanned(email){ const b = getBanned(); return b.includes((email||'').toLowerCase()); }
function addBan(email){ if(!email) return; const b = getBanned(); if(!b.includes(email.toLowerCase())){ b.push(email.toLowerCase()); localStorage.setItem(BANNED_STORAGE_KEY, JSON.stringify(b)); } }

function reportChat(msgId){
  // Allow optional reason param. If omitted, prompt the user.
  let reason;
  try{ reason = arguments.length > 1 ? arguments[1] : undefined; }catch(e){ reason = undefined; }
  if(typeof reason === 'undefined'){
    reason = prompt('Why are you reporting this message? (optional)');
    if(reason === null) return; // user cancelled
  }
  const msg = chatMessages.find(m=>m.id===msgId);
  if(!msg) return alert('Message not found');
  // mark in chatMessages
  msg.reported = true;
  // store report (local fallback)
  const reports = JSON.parse(localStorage.getItem(REPORTS_STORAGE_KEY) || '[]');
  reports.push({ id: 'r_'+Date.now()+'_'+Math.random().toString(36).slice(2,6), msgId: msg.id, text: msg.text, from: msg.from, email: msg.email, ts: msg.ts, reportedAt: Date.now(), reason: reason || '' });
  localStorage.setItem(REPORTS_STORAGE_KEY, JSON.stringify(reports));
  localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(chatMessages));
  renderChatMessages();
  alert('âœ… Message reported. Admins will review it.');
}

function loadReportedChats(){
  try{ return JSON.parse(localStorage.getItem(REPORTS_STORAGE_KEY) || '[]'); }catch(e){ return []; }
}

function renderAdminContent(){
  const container = document.getElementById('adminContent');
  if(!container) return;
  const reports = loadReportedChats();
  if(reports.length===0){ container.innerHTML = '<div class="text-sm muted py-6">No reported chats.</div>'; return; }
  container.innerHTML = '';
  reports.forEach(r=>{
    const row = document.createElement('div');
    row.className = 'p-3 mb-3 border rounded';
    row.innerHTML = `
      <div class="text-sm font-semibold">${escapeHtml(r.from)} <span class="text-xs muted">(${escapeHtml(r.email)})</span></div>
      <div class="text-xs muted">${new Date(r.reportedAt).toLocaleString()} â€” original: ${escapeHtml(r.ts)}</div>
      <div class="mt-2 text-sm">${escapeHtml(r.text)}</div>
      ${r.reason ? `<div class="mt-1 text-sm muted"><strong>Reason:</strong> ${escapeHtml(r.reason || '')}</div>` : ''}
      <div class="mt-3 flex gap-2">
        <button class="admin-delete px-2 py-1 rounded bg-red-600 text-white" data-msg="${r.msgId}" data-report="${r.id}">Delete Chat</button>
        <button class="admin-ban px-2 py-1 rounded bg-gray-800 text-white" data-email="${escapeHtml(r.email)}">Ban User</button>
        <button class="admin-dismiss px-2 py-1 rounded bg-gray-200" data-report="${r.id}">Dismiss</button>
      </div>
    `;
    container.appendChild(row);
  });
  // bind actions
  Array.from(container.querySelectorAll('.admin-delete')).forEach(b=> b.addEventListener('click', ()=>{
    const msgId = b.dataset.msg; const reportId = b.dataset.report;
    if(!confirm('Delete this chat for everyone?')) return;
    // remove chat
    chatMessages = chatMessages.filter(m=>m.id!==msgId);
    localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(chatMessages));
    // remove report
    let reports = loadReportedChats(); reports = reports.filter(r=>r.id!==reportId); localStorage.setItem(REPORTS_STORAGE_KEY, JSON.stringify(reports));
    renderAdminContent(); renderChatMessages();
  }));
  Array.from(container.querySelectorAll('.admin-ban')).forEach(b=> b.addEventListener('click', ()=>{
    const email = b.dataset.email;
    if(!confirm('Ban user '+email+'? This will prevent them from logging in or sending messages.')) return;
    addBan(email);
    // remove their chats
    chatMessages = chatMessages.filter(m=>m.email !== email);
    localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(chatMessages));
    // remove related reports
    let reports = loadReportedChats(); reports = reports.filter(r=>r.email !== email); localStorage.setItem(REPORTS_STORAGE_KEY, JSON.stringify(reports));
    renderAdminContent(); renderChatMessages();
    // if banned user is currently logged in, log them out
    const cur = getEffectiveUser(); if(cur && cur.email === email){ logout(); alert('Banned user was logged out.'); }
  }));
  Array.from(container.querySelectorAll('.admin-dismiss')).forEach(b=> b.addEventListener('click', ()=>{
    const reportId = b.dataset.report; let reports = loadReportedChats(); reports = reports.filter(r=>r.id!==reportId); localStorage.setItem(REPORTS_STORAGE_KEY, JSON.stringify(reports)); renderAdminContent();
  }));
}

function updateAdminUI(){
  const cur = getEffectiveUser();
  const openAdminBtn = document.getElementById('openAdminBtn');
  const adminOverlay = document.getElementById('adminOverlay');
  if(openAdminBtn){
    if(cur && isAdmin(cur.email)){ openAdminBtn.classList.remove('hidden'); } else { openAdminBtn.classList.add('hidden'); }
    openAdminBtn.onclick = ()=>{
      // Redirect to dedicated admin dashboard
      window.location.href = 'admin.html';
    };
  }
  const closeAdmin = document.getElementById('closeAdmin'); if(closeAdmin) closeAdmin.onclick = ()=> adminOverlay.classList.add('hidden');
  const adminRefresh = document.getElementById('adminRefresh'); if(adminRefresh) adminRefresh.onclick = ()=> renderAdminContent();
}

// initialize admin UI on load
try{ updateAdminUI(); }catch(e){}

/* small escape util */
function escapeHtml(s){ return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#039;'); }

/* Accessibility: Esc to close overlays */
window.addEventListener('keydown', e=> { if(e.key==='Escape'){ if(!authOverlay.classList.contains('hidden')) closeAuth(); if(!profileOverlay.classList.contains('hidden')) profileOverlay.classList.add('hidden'); } });

/* FEATURED IMAGES SLIDESHOW */
function initFeaturedImages() {
  const track = document.getElementById('imagesTrack');
  if(!track) {
    console.error('Featured images track not found');
    return false;
  }
  const slides = Array.from(track.children);
  if(!slides.length) {
    console.error('No featured image slides found');
    return false;
  }
  const N = slides.length;
  console.log('Featured images initialized with', N, 'slides');
  
  // Clone first and last for infinite loop
  const firstClone = slides[0].cloneNode(true);
  const lastClone = slides[N-1].cloneNode(true);
  firstClone.classList.add('clone');
  lastClone.classList.add('clone');
  track.insertBefore(lastClone, track.firstChild);
  track.appendChild(firstClone);
  
  let idx = 0;
  let anim = false;
  let autoPlayInterval = null;
  const dots = [
    document.getElementById('imgDot0'),
    document.getElementById('imgDot1'),
    document.getElementById('imgDot2'),
    document.getElementById('imgDot3'),
    document.getElementById('imgDot4')
  ].filter(d => d !== null);
  
  function slideWidth(){
    return track.parentElement.getBoundingClientRect().width;
  }
  
  function setPos(i){
    const w = slideWidth();
    track.style.transition = 'none';
    track.style.transform = `translateX(-${(i+1)*w}px)`;
  }
  
  function updateDots(){
    dots.forEach((d, i) => {
      if(!d) return;
      d.classList.toggle('active', i === idx);
      d.style.background = i === idx ? 'var(--dot-active)' : 'var(--dot-inactive)';
    });
  }
  
  function goTo(target){
    if(anim) return;
    anim = true;
    const w = slideWidth();
    const visual = target + 1;
    track.style.transition = 'transform .5s cubic-bezier(.2,.9,.12,1)';
    track.style.transform = `translateX(-${visual * w}px)`;
    
    const onEnd = () => {
      track.removeEventListener('transitionend', onEnd);
      if(visual === 0){
        track.style.transition = 'none';
        track.style.transform = `translateX(-${N * w}px)`;
        target = N - 1;
      } else if(visual === N + 1){
        track.style.transition = 'none';
        track.style.transform = `translateX(-${1 * w}px)`;
        target = 0;
      }
      idx = (target + N) % N;
      updateDots();
      setTimeout(() => { anim = false; }, 30);
    };
    track.addEventListener('transitionend', onEnd);
  }
  
  function next(){
    goTo(idx + 1);
    resetAutoPlay();
  }
  
  function prev(){
    goTo(idx - 1);
    resetAutoPlay();
  }
  
  function startAutoPlay(){
    autoPlayInterval = setInterval(() => {
      next();
    }, 4000); // Auto-advance every 4 seconds
  }
  
  function resetAutoPlay(){
    if(autoPlayInterval){
      clearInterval(autoPlayInterval);
      startAutoPlay();
    }
  }
  
  // Bind arrows
  const prevBtn = document.getElementById('prevImage');
  const nextBtn = document.getElementById('nextImage');
  if(prevBtn) {
    prevBtn.addEventListener('click', (e) => {
      e.preventDefault();
      console.log('Previous image button clicked');
      prev();
    });
  } else {
    console.error('prevImage button not found');
  }
  if(nextBtn) {
    nextBtn.addEventListener('click', (e) => {
      e.preventDefault();
      console.log('Next image button clicked');
      next();
    });
  } else {
    console.error('nextImage button not found');
  }
  
  // Bind dots
  dots.forEach((d, i) => {
    if(!d) return;
    d.addEventListener('click', () => {
      console.log('Dot clicked:', i);
      goTo(parseInt(d.dataset.index));
      resetAutoPlay();
    });
  });
  
  // Swipe support
  (function(){
    let sx = 0;
    const view = track.parentElement;
    view.addEventListener('touchstart', e => {
      sx = e.touches[0].clientX;
    });
    view.addEventListener('touchend', e => {
      const diff = e.changedTouches[0].clientX - sx;
      if(diff > 50) prev();
      if(diff < -50) next();
    });
  })();
  
  // Keyboard navigation
  window.addEventListener('keydown', e => {
    if(['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;
    if(e.key === 'ArrowLeft') prev();
    if(e.key === 'ArrowRight') next();
  });
  
  // Add error handling for images
  const allImages = track.querySelectorAll('img');
  let imagesLoaded = 0;
  allImages.forEach(img => {
    if(img.complete) {
      imagesLoaded++;
    }
    img.addEventListener('load', () => {
      imagesLoaded++;
      console.log('Featured image loaded:', img.src);
    });
    img.addEventListener('error', (e) => {
      console.error('Failed to load featured image:', img.src);
      // Add fallback background
      img.parentElement.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
      img.style.display = 'none';
    });
  });
  
  // Initialize
  function init() {
    console.log('Initializing featured images carousel');
    console.log('Slide width:', slideWidth());
    console.log('Current index:', idx);
    setPos(0);
    updateDots();
    startAutoPlay();
    console.log('Featured images carousel started with autoplay');
    
    // Force a repaint
    track.style.display = 'flex';
  }
  
  // Run initialization after a delay to ensure DOM is ready
  if(document.readyState === 'loading') {
    window.addEventListener('DOMContentLoaded', () => {
      setTimeout(init, 200);
    });
  } else {
    // DOM already loaded
    setTimeout(init, 200);
  }
  
  window.addEventListener('load', () => {
    setTimeout(() => {
      setPos(idx);
      console.log('Window loaded, repositioning slides');
    }, 300);
  });
  
  window.addEventListener('resize', () => {
    console.log('Window resized, repositioning');
    setPos(idx);
  });
  
  // Pause auto-play on hover
  const viewport = document.querySelector('.images-viewport');
  if(viewport){
    viewport.addEventListener('mouseenter', () => {
      if(autoPlayInterval) {
        clearInterval(autoPlayInterval);
        console.log('Featured images autoplay paused');
      }
    });
    viewport.addEventListener('mouseleave', () => {
      startAutoPlay();
      console.log('Featured images autoplay resumed');
    });
  }
  return true;
}

// Call initialization when DOM is ready
if(document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initFeaturedImages);
} else {
  initFeaturedImages();
}

</script>

<!-- Robust fallback for send button: ensures sending works even if other JS fails -->
<script>
  (function(){
    function createFallbackMessageDOM(msg){
      try{
        const w = document.getElementById('chatWindow');
        if(!w) return;
        const container = document.createElement('div'); container.className = 'chat-message-own';
        const avatar = document.createElement('div'); avatar.className = 'chat-avatar'; avatar.textContent = (msg.from||'U').charAt(0).toUpperCase();
        const content = document.createElement('div'); content.className = 'chat-content';
        const header = document.createElement('div'); header.className = 'chat-header'; header.innerHTML = `<strong>${(msg.from||'You')}</strong> <span class="chat-time">${msg.ts}</span>`;
        const bubble = document.createElement('div'); bubble.className = 'chat-bubble-own'; bubble.innerHTML = `<div class="text-sm">${(msg.text||'')}</div>`;
        content.appendChild(header); content.appendChild(bubble);
        container.appendChild(content); container.appendChild(avatar);
        w.appendChild(container);
        w.scrollTop = w.scrollHeight;
      }catch(e){ console.warn('fallback dom append failed', e); }
    }

    function showChatNotice(text, actionLabel, actionFn){
      try{
        let n = document.getElementById('chatSendNotice');
        if(!n){
          n = document.createElement('div'); n.id = 'chatSendNotice';
          n.style.position = 'fixed'; n.style.right = '12px'; n.style.bottom = '72px'; n.style.zIndex = 10001;
          n.style.background = '#fffaf0'; n.style.border = '1px solid #ffe4b5'; n.style.padding = '8px 12px'; n.style.borderRadius = '8px';
          n.style.boxShadow = '0 2px 8px rgba(0,0,0,0.08)'; n.style.color = '#7a4a00';
          document.body.appendChild(n);
        }
        n.innerHTML = '';
        const span = document.createElement('span'); span.textContent = text; n.appendChild(span);
        if(actionLabel && actionFn){ const btn = document.createElement('button'); btn.textContent = actionLabel; btn.style.marginLeft='8px'; btn.className='px-2 py-1 rounded bg-indigo-600 text-white'; btn.onclick = actionFn; n.appendChild(btn); }
        setTimeout(()=>{ try{ n.remove(); }catch(e){} }, 7000);
      }catch(e){ console.warn('showChatNotice failed', e); }
    }

    async function fallbackSend(){
      try{
        const input = document.getElementById('messageInput'); if(!input) return;
        const txt = (input.value||'').trim(); if(!txt) return;
        const eff = (typeof getEffectiveUser === 'function') ? getEffectiveUser() : null;
        const msg = { from: eff && eff.name ? eff.name : (eff && eff.email ? eff.email.split('@')[0] : 'Anonymous'), email: eff && eff.email ? eff.email : 'anonymous@local', text: txt, ts: new Date().toLocaleTimeString(), timestamp: Date.now() };

        // Prefer Firebase send when signed-in
        if(window._firebase && window._firebase.auth && window._firebase.auth.currentUser && typeof window.sendChatMessage === 'function'){
          const inputEl = document.getElementById('messageInput'); if(inputEl) inputEl.value = msg.text;
          try{ await window.sendChatMessage(); if(inputEl) inputEl.value = ''; return; }catch(e){ console.warn('Firebase send failed, falling back to server:', e); }
        }

        // Try server fallback: POST to /api/messages
        // Optimistic UI: append to window.chatMessages and render
        window.chatMessages = window.chatMessages || [];
        const localMsg = Object.assign({}, msg, { id: 'local_' + Date.now() });
        window.chatMessages.push(localMsg);
        if(window.chatMessages.length > 30) window.chatMessages = window.chatMessages.slice(-30);
        renderChatMessages();
        input.value = '';

        try{
          const resp = await fetch('/api/messages', { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(msg) });
          if(resp && resp.ok){ const j = await resp.json(); if(j && j.success && j.id){ // update id
              localMsg.id = j.id;
            }
            showChatNotice('Message saved via server fallback.');
            return;
          }
          showChatNotice('Server persist failed. Message shown locally.');
        }catch(e){ console.warn('Server fallback POST failed', e); showChatNotice('Server persist failed (offline).'); }

        // If server also not available, keep optimistic UI until Firestore becomes available
      }catch(e){ console.error('fallbackSend error', e); }
    }

    // attach handlers after DOM ready
    function attach(){
      const btn = document.getElementById('sendBtn');
      const input = document.getElementById('messageInput');
        if(btn){ btn.addEventListener('click', (e)=>{ try{
          console.debug('[DEBUG] sendBtn clicked', { hasFirebase: !!(window._firebase && window._firebase.auth && window._firebase.auth.currentUser), hasSendFn: typeof window.sendChatMessage === 'function' });
          // prefer Firebase send only when signed-in
          if(typeof window.sendChatMessage === 'function' && window.sendChatMessage !== fallbackSend && window._firebase && window._firebase.auth && window._firebase.auth.currentUser){ try{ window.sendChatMessage(); return; }catch(er){ console.warn('window.sendChatMessage failed, falling back', er); } }
          fallbackSend(); }catch(ex){ console.error('sendBtn handler crash', ex); } }); }
        if(input){ input.addEventListener('keypress', (e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); console.debug('[DEBUG] messageInput Enter pressed'); if(typeof window.sendChatMessage === 'function' && window.sendChatMessage !== fallbackSend && window._firebase && window._firebase.auth && window._firebase.auth.currentUser){ try{ window.sendChatMessage(); return; }catch(er){} } fallbackSend(); } }); }
    }

    if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', attach); else attach();
  })();
</script>

<script type="module">
  // Firebase integration: Auth + Realtime Database (RTDB) for chat, reports, admin
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js";
  import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, updateProfile, sendEmailVerification, EmailAuthProvider, reauthenticateWithCredential, updatePassword } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-auth.js";
  import { getDatabase, ref, push, set, get, onValue, off, update, remove, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-database.js";

  // Fetch Firebase config from server (kept out of public code for security)
  let firebaseConfig = null;
  try {
    const response = await fetch('/api/firebase-config');
    firebaseConfig = await response.json();
    console.log('[DEBUG] /api/firebase-config response:', firebaseConfig);
  } catch (err) {
    console.error('Failed to fetch Firebase config:', err);
    firebaseConfig = null;
  }

  // Only use Firebase auth when a complete config is present (prevents partial/misconfigured envs from disabling local OTP)
  const hasApiKey = firebaseConfig && firebaseConfig.apiKey && String(firebaseConfig.apiKey).trim() !== '';
  const hasAuthDomain = firebaseConfig && firebaseConfig.authDomain && String(firebaseConfig.authDomain).trim() !== '';
  const hasProjectId = firebaseConfig && firebaseConfig.projectId && String(firebaseConfig.projectId).trim() !== '';
  const hasAppId = firebaseConfig && firebaseConfig.appId && String(firebaseConfig.appId).trim() !== '';

  if (!(hasApiKey && hasAuthDomain && hasProjectId && hasAppId)) {
    console.warn('Firebase config incomplete or missing required fields. Falling back to local OTP flow.');
    window._useFirebaseAuth = false;
  } else {
    const app = initializeApp(firebaseConfig);
    console.log('[DEBUG] Initializing Firebase with config (masked):', { apiKey: firebaseConfig.apiKey ? '***' : '', authDomain: firebaseConfig.authDomain });
    // indicate Firebase handlers are active so legacy local handlers skip
    window._useFirebaseAuth = true;
    const auth = getAuth(app);
    // Initialize Realtime Database (RTDB) instead of Firestore
    const db = getDatabase(app);
    console.log('[DEBUG] Firebase Realtime Database initialized');
    // expose firebase objects for legacy handlers
    window._firebase = { app, auth, db };
    console.log('[DEBUG] window._firebase set', !!window._firebase && !!window._firebase.auth && !!window._firebase.db);

  // listeners / state
  let unsubscribeChats = null;
  let unsubscribeReports = null;

  // helper to convert RTDB timestamp
  function formatTs(ts){ try{ if(!ts) return ''; const d = new Date(ts); return d.toLocaleTimeString(); }catch(e){ return ''; } }

  // Override sendChatMessage to write to RTDB with instant local rendering
  window.sendChatMessage = async function(){
    const user = auth.currentUser;
    console.log('[DEBUG] window.sendChatMessage called, auth.currentUser:', user && user.email);
    if(!user){ openAuth('login'); return; }
    // check banned
    try{
      const bannedRef = ref(db, `banned/${user.uid}`);
      const bannedSnap = await get(bannedRef);
      if(bannedSnap.exists()){
        alert('Your account has been banned.');
        await signOut(auth);
        return;
      }
    }catch(e){ console.warn('Failed to check ban status', e); }
    
    const txt = document.getElementById('messageInput').value.trim();
    if(!txt) return;
    
    const messageInput = document.getElementById('messageInput');
    const chatWindow = document.getElementById('chatWindow');
    
    try{
      // Create local message instantly (before RTDB commit)
      const localMsg = {
        id: 'local_' + Date.now() + '_' + Math.random().toString(36).slice(2,8),
        from: user.displayName || user.email.split('@')[0],
        email: user.email,
        text: txt,
        ts: new Date().toLocaleTimeString(),
        timestamp: new Date(),
        uid: user.uid,
        pending: true,
        reported: false
      };
      
      // Render message locally immediately (no wait for RTDB)
      window.chatMessages = window.chatMessages || [];
      window.chatMessages.push(localMsg);
      renderChatMessages();
      messageInput.value = '';
      
      // Now send to RTDB (async, doesn't block UI)
      const payload = {
        uid: user.uid,
        from: localMsg.from,
        email: user.email,
        text: txt,
        timestamp: Date.now()
      };
      console.debug('[DEBUG] RTDB write payload (chats):', payload);
      
      // Push to chats node, get the key
      const chatsRef = ref(db, 'chats');
      const newMsgRef = push(chatsRef);
      const msgKey = newMsgRef.key;
      await set(newMsgRef, payload);
      
      // Once RTDB confirms, update message ID and remove pending flag
      const msgIdx = window.chatMessages.findIndex(m => m.id === localMsg.id);
      if(msgIdx >= 0){
        window.chatMessages[msgIdx].id = msgKey;
        window.chatMessages[msgIdx].pending = false;
        renderChatMessages();
      }
      console.debug('[DEBUG] Message confirmed by RTDB with key:', msgKey);
    }catch(err){
      console.error('[DEBUG] sendChatMessage failed:', err);
      // Mark as failed in UI
      const msgIdx = window.chatMessages.findIndex(m => m.pending && m.email === user.email && m.text === txt);
      if(msgIdx >= 0){
        window.chatMessages[msgIdx].pending = false;
        window.chatMessages[msgIdx].failed = true;
        renderChatMessages();
      }
      alert('Failed to send message: ' + (err.message || 'unknown error'));
    }
  };

    // Wrap sendChatMessage with debug logging to capture errors and calls
    try{
      if(window.sendChatMessage && typeof window.sendChatMessage === 'function'){
        const __origSend = window.sendChatMessage;
        window.sendChatMessage = async function(){
          console.debug('[DEBUG] sendChatMessage invoked', { authUser: (auth && auth.currentUser) ? auth.currentUser.email : null });
          try{
            const res = await __origSend.apply(this, arguments);
            console.debug('[DEBUG] sendChatMessage succeeded');
            return res;
          }catch(err){
            console.error('[DEBUG] sendChatMessage failed', err);
            // If RTDB write fails, fall back to server-side persistence so UX isn't blocked.
            try{
              const permDenied = err && (err.code === 'PERMISSION_DENIED' || (err.message && err.message.indexOf('PERMISSION_DENIED') !== -1));
              if(permDenied){
                console.warn('[DEBUG] sendChatMessage permission denied â€” falling back to server POST');
                // Use fallbackSend if available (defined earlier in page), otherwise manual POST
                if(typeof fallbackSend === 'function'){
                  try{ await fallbackSend(); return; }catch(e2){ console.warn('fallbackSend failed', e2); }
                }
                // manual fallback
                try{
                  const input = document.getElementById('messageInput');
                  const txt = input ? input.value.trim() : '';
                  const eff = (typeof getEffectiveUser === 'function') ? getEffectiveUser() : null;
                  const msg = { from: eff && eff.name ? eff.name : (eff && eff.email ? eff.email.split('@')[0] : 'Anonymous'), email: eff && eff.email ? eff.email : 'anonymous@local', text: txt, ts: new Date().toLocaleTimeString(), timestamp: Date.now() };
                  await fetch('/api/messages', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(msg) });
                  if(input) input.value = '';
                  return;
                }catch(e3){ console.warn('Manual POST fallback failed', e3); }
              }
            }catch(inner){ console.warn('sendChatMessage fallback handler error', inner); }
            throw err;
          }
        };
      }
    }catch(e){ console.warn('Could not wrap sendChatMessage for debug', e); }

  // start listening to latest chats â€” use onValue for real-time updates from RTDB
  function startChatListener(){
    if(unsubscribeChats) return;
    console.log('[DEBUG] startChatListener - setting up listener on chats ref');
    const chatsRef = ref(db, 'chats');
    try{
      unsubscribeChats = onValue(chatsRef, snap => {
        console.log('[DEBUG] RTDB chats snapshot received');
        window.chatMessages = window.chatMessages || [];
        
        if(!snap.exists()){
          console.log('[DEBUG] No chats in RTDB yet');
          return;
        }
        
        // RTDB returns object with keys as message IDs
        const data = snap.val();
        const allMsgs = [];
        Object.keys(data || {}).forEach(msgId => {
          const msgData = data[msgId];
          const msg = { 
            id: msgId, 
            from: msgData.from, 
            email: msgData.email, 
            text: msgData.text, 
            ts: formatTs(msgData.timestamp), 
            timestamp: msgData.timestamp, 
            uid: msgData.uid, 
            reported: msgData.reported || false 
          };
          allMsgs.push(msg);
        });
        
        // Sort by timestamp ascending
        allMsgs.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
        
        // Keep only last 50 messages
        if(allMsgs.length > 50) allMsgs = allMsgs.slice(-50);
        
        // Replace window.chatMessages with sorted list
        window.chatMessages = allMsgs;
        console.log('[DEBUG] Updated messages list with', window.chatMessages.length, 'messages');
        
        // Render after changes
        try{ const s = document.getElementById('chatStatus'); if(s) s.textContent = ''; }catch(e){}
        renderChatMessages();
    }, err=> {
      console.error('[DEBUG] RTDB chat listener error:', err && err.code ? err.code : 'unknown', err && err.message ? err.message : '');
      try{
        const s = document.getElementById('chatStatus') || (function(){ const el = document.createElement('div'); el.id='chatStatus'; el.style.padding='8px'; el.style.background='#fff3cd'; el.style.color='#856404'; el.style.border='1px solid #ffeeba'; el.style.borderRadius='6px'; el.style.position='fixed'; el.style.right='12px'; el.style.bottom='12px'; el.style.zIndex=9999; document.body.appendChild(el); return el; })();
        const msg = (err && err.code === 'PERMISSION_DENIED') ? 'ðŸ”’ Chat read denied â€” check RTDB rules.' : 'RTDB chat error â€” using server fallback.';
        s.textContent = msg;
      }catch(e2){ console.warn('Failed to render chat status', e2); }
      // fallback: stop listener and try server-side messages, then local
      if(unsubscribeChats){ unsubscribeChats(); unsubscribeChats = null; }
      (async ()=>{
        try{
          console.log('[DEBUG] Attempting /api/messages fallback after RTDB error');
          const resp = await fetch('/api/messages');
          if(resp && resp.ok){ const j = await resp.json(); if(j && j.success && Array.isArray(j.messages)){ console.log('[DEBUG] /api/messages fallback returned', j.messages.length, 'messages'); window.chatMessages = j.messages; renderChatMessages(); return; } }
        }catch(e){ console.debug('Failed to fetch /api/messages fallback', e); }
        // Use cached local messages if available
        if(!window.chatMessages || window.chatMessages.length === 0){
          window.chatMessages = JSON.parse(localStorage.getItem(CHAT_STORAGE_KEY) || '[]');
        }
        renderChatMessages();
      })();
    });
    }catch(e){ console.error('[DEBUG] startChatListener setup failed:', e); }
  }
  
  // Expose to window for cross-scope access
  window.startChatListener = startChatListener;

  function stopChatListener(){ if(unsubscribeChats){ unsubscribeChats(); unsubscribeChats = null; } }

  // report chat -> add to reports node and mark chat
  window.reportChat = async function(msgId){
    // Accept optional reason parameter; prompt if not provided
    const user = auth.currentUser; if(!user){ openAuth('login'); return; }
    let reason = arguments.length > 1 ? arguments[1] : undefined;
    if(typeof reason === 'undefined'){
      reason = prompt('Why are you reporting this message? (optional)');
      if(reason === null) return; // cancelled
    }
    console.debug('[DEBUG] reportChat: looking for msgId:', msgId, 'reason:', reason);
    try{
      const chatRef = ref(db, `chats/${msgId}`);
      const chatSnap = await get(chatRef);
      if(!chatSnap.exists()){ console.warn('[DEBUG] reportChat: doc not found for id:', msgId); alert('Message not found'); return; }
      const data = chatSnap.val();
      
      // Create report entry (include reason)
      const reportPayload = { 
        msgId, 
        chatText: data.text, 
        from: data.from, 
        email: data.email, 
        uid: data.uid || null, 
        reportedBy: user.email, 
        reportedAt: Date.now(),
        reason: reason || ''
      };
      
      const reportsRef = ref(db, 'reports');
      const newReportRef = push(reportsRef);
      await set(newReportRef, reportPayload);
      
      // Mark message as reported
      await update(chatRef, { reported: true });
      alert('Reported. Admins will review.');
    }catch(err){ 
      console.error('[DEBUG] reportChat error:', err); 
      const msg = (err && err.code === 'PERMISSION_DENIED') ? 'Report failed: Permission denied â€” check Firebase rules.' : 'Report failed: ' + (err.message || 'unknown error');
      alert(msg); 
    }
  };

  // Admin: listen to reports
  function startReportsListener(){
    if(unsubscribeReports) return;
    const reportsRef = ref(db, 'reports');
    unsubscribeReports = onValue(reportsRef, snap => {
      const rows = [];
      if(snap.exists()){
        const data = snap.val();
        Object.keys(data).forEach(reportId => {
          rows.push({ id: reportId, ...data[reportId] });
        });
      }
      // Sort by reportedAt descending (newest first)
      rows.sort((a, b) => (b.reportedAt || 0) - (a.reportedAt || 0));
      
      // render admin content
      const container = document.getElementById('adminContent');
      if(!container) return;
      if(rows.length===0){ container.innerHTML = '<div class="text-sm muted py-6">No reported chats.</div>'; return; }
      container.innerHTML = '';
      rows.forEach(r=>{
        const row = document.createElement('div');
        row.className = 'p-3 mb-3 border rounded';
        row.innerHTML = `
          <div class="text-sm font-semibold">${escapeHtml(r.from)} <span class="text-xs muted">(${escapeHtml(r.email)})</span></div>
          <div class="text-xs muted">${new Date(r.reportedAt || Date.now()).toLocaleString()}</div>
            <div class="mt-2 text-sm">${escapeHtml(r.chatText)}</div>
            ${r.reason ? `<div class="mt-1 text-sm muted"><strong>Reason:</strong> ${escapeHtml(r.reason || '')}</div>` : ''}
          <div class="mt-3 flex gap-2">
            <button class="admin-delete px-2 py-1 rounded bg-red-600 text-white" data-msg="${escapeHtml(r.msgId)}" data-report="${r.id}">Delete Chat</button>
            <button class="admin-ban px-2 py-1 rounded bg-gray-800 text-white" data-email="${escapeHtml(r.email)}" data-uid="${escapeHtml(r.uid||'')}">Ban User</button>
            <button class="admin-dismiss px-2 py-1 rounded bg-gray-200" data-report="${r.id}">Dismiss</button>
          </div>
        `;
        container.appendChild(row);
      });
      // bind actions
      Array.from(container.querySelectorAll('.admin-delete')).forEach(b=> b.addEventListener('click', async ()=>{
        const msgId = b.dataset.msg; const reportId = b.dataset.report;
        if(!confirm('Delete this chat for everyone?')) return;
        try{ 
          await remove(ref(db, `chats/${msgId}`)); 
          await remove(ref(db, `reports/${reportId}`)); 
          alert('Deleted'); 
        }
        catch(e){ console.error(e); alert('Failed to delete'); }
      }));
      Array.from(container.querySelectorAll('.admin-ban')).forEach(b=> b.addEventListener('click', async ()=>{
        const email = b.dataset.email; const uid = b.dataset.uid;
        if(!confirm('Ban user '+email+'?')) return;
        try{
          if(uid){ await set(ref(db, `banned/${uid}`), { email, bannedAt: Date.now() }); }
          else { await set(ref(db, `banned/${email}`), { email, bannedAt: Date.now() }); }
          alert('User banned.');
        }catch(e){ console.error(e); alert('Failed to ban'); }
      }));
      Array.from(container.querySelectorAll('.admin-dismiss')).forEach(b=> b.addEventListener('click', async ()=>{
        const reportId = b.dataset.report; try{ await remove(ref(db, `reports/${reportId}`)); }catch(e){ console.error(e); }
      }));
    }, err=> console.error('reports listener', err));
  }
  function stopReportsListener(){ if(unsubscribeReports){ unsubscribeReports(); unsubscribeReports=null; } }

  // admin check: check 'admins' ref node with uid
  window.checkIsAdmin = async function(uid){ if(!uid) return false; const snap = await get(ref(db, `admins/${uid}`)); return snap.exists(); };
  async function checkIsAdmin(uid){ if(!uid) return false; const snap = await get(ref(db, `admins/${uid}`)); return snap.exists(); }

  // on auth state change
  onAuthStateChanged(auth, async (user) => {
    console.log('[DEBUG] onAuthStateChanged - user:', user);
    if(user){
      // check banned (wrap in try/catch so a read error doesn't forcibly sign the user out)
      try{
        const bannedSnap = await get(ref(db, `banned/${user.uid}`));
        if(bannedSnap && bannedSnap.exists()){
          alert('Your account is banned.'); await signOut(auth); return; }
      }catch(bErr){
        console.warn('Could not read banned status (continuing):', bErr);
      }

      // require email verification OR allow OTP-verified users (OTP flow sets otpVerified in RTDB)
      if(user && !user.emailVerified){
        try{
          const ud = await get(ref(db, `users/${user.uid}`));
          const ok = ud && ud.exists() && ud.val() && ud.val().otpVerified;
          if(!ok){
            // If the users node says not otpVerified, force sign out
            alert('Please verify your email address before using the site. A verification link was sent to your email.');
            await signOut(auth);
            return;
          } else {
            // user has been OTP-verified; allow login without email verification
            console.log('User OTP-verified; allowing sign-in without emailVerified flag.', ud.val());
          }
        }catch(e){
          // Don't sign the user out if reading the users node fails (e.g., security rules); log and proceed
          console.warn('Failed to check OTP verification status â€” proceeding without blocking sign-in:', e);
          // Optionally notify in-console only; avoid alert to reduce UX friction
        }
      }
      // check if admin - redirect to admin dashboard if true
      const isAdmin = await checkIsAdmin(user.uid);
      if(isAdmin){
        // Redirect to admin dashboard
        window.location.href = 'admin.html';
        return;
      }
      // load user profile
      let name = user.displayName || '';
      try{ const ud = await get(ref(db, `users/${user.uid}`)); if(ud.exists() && ud.val().name) name = ud.val().name; }catch(e){}
      setCurrentUser({ uid: user.uid, email: user.email, name });
      // start listeners
      try{ startChatListener(); }catch(e){ console.error('startChatListener threw', e); }
      // show clear button (should be hidden since not admin, but keep for future)
      const clearChatBtn = document.getElementById('clearChatBtn');
      if(clearChatBtn){ clearChatBtn.classList.add('hidden'); }
    } else {
      // logged out - silently clear, don't show alert on page load
      logout(false);
      stopChatListener(); stopReportsListener();
    }
  });

  // Also attempt to start chat listener immediately so public/unauthenticated users can see messages
  // Delay to ensure renderChatMessages is available on window object
  setTimeout(async ()=>{
    try{
      // First, load server-side messages so chat is never empty on initial load
      try{
        console.log('[DEBUG] Initial load: fetching /api/messages for immediate chat display');
        const resp = await fetch('/api/messages');
        if(resp && resp.ok){
          const j = await resp.json();
          if(j && j.success && Array.isArray(j.messages) && j.messages.length > 0){
            console.log('[DEBUG] Initial /api/messages load:', j.messages.length, 'messages');
            window.chatMessages = j.messages;
            // Call renderChatMessages if it exists globally
            console.log('[DEBUG] window.renderChatMessages available?', typeof window.renderChatMessages === 'function');
            if(typeof window.renderChatMessages === 'function'){
              window.renderChatMessages();
            } else {
              console.warn('[DEBUG] renderChatMessages not available on window object');
            }
          }
        }
      }catch(e){ console.debug('Initial /api/messages load failed', e); }
      // Then start Firestore listener (which may be blocked by rules, but will provide realtime updates if it works)
      console.log('[DEBUG] window.startChatListener available?', typeof window.startChatListener === 'function');
      if(typeof window.startChatListener === 'function'){
        window.startChatListener();
      } else {
        console.warn('[DEBUG] startChatListener not available on window object');
      }
    }catch(e){ console.warn('Immediate startChatListener attempt failed:', e); }
  }, 100);

  // replace login/signup behavior to use Firebase (override previous handlers)
  try{
    const _loginForm = document.getElementById('loginForm');
    if(_loginForm){ _loginForm.addEventListener('submit', async (e)=>{
      e.preventDefault();
      const email = document.getElementById('loginEmail').value.trim().toLowerCase();
      const pwd = document.getElementById('loginPassword').value;
      if(!email || !pwd){ alert('Enter email and password'); return; }
      try{
        const cred = await signInWithEmailAndPassword(auth, email, pwd);
        // Immediately update UI before waiting for onAuthStateChanged listener
        const user = cred.user;
        let name = user.displayName || '';
        try{ const ud = await get(ref(db, `users/${user.uid}`)); if(ud.exists() && ud.val().name) name = ud.val().name; }catch(e){}
        setCurrentUser({ uid: user.uid, email: user.email, name });
        // Also start chat listener immediately
        try{ startChatListener(); }catch(e){ console.error('startChatListener after login failed', e); }
        closeAuth();
        alert('Logged in');
      }
      catch(err){ console.error(err); alert('Login failed: '+err.message); }
    }); }

    const _signupForm = document.getElementById('signupForm');
    if(_signupForm){
      // If Firebase auth is enabled we use a server-backed OTP flow before creating the user.
      if(window._useFirebaseAuth){
        const sendOtpBtnEl = document.getElementById('sendOtpBtn');
        const verifyOtpBtnEl = document.getElementById('verifyOtpBtn');
        let pending = null;

        if(sendOtpBtnEl){
          sendOtpBtnEl.addEventListener('click', async (e)=>{
            e.preventDefault();
            const name = document.getElementById('signupName').value.trim();
            const email = document.getElementById('signupEmail').value.trim().toLowerCase();
            const pwd = document.getElementById('signupPassword').value;
            if(!name || !email || !pwd){ alert('Fill all fields'); return; }
            try{
              const r = await fetch('/api/send-otp', { method:'POST', headers:{ 'content-type':'application/json' }, body: JSON.stringify({ name, email }) });
              const j = await r.json();
              if(!r.ok){ console.error('send-otp failed', j); alert('Failed to send OTP: '+(j.error||j.detail||'server error')); return; }
              pending = { name, email, password: pwd, token: j.token };
              otpTarget.innerText = email;
              openAuth('otp');
              alert('OTP sent to your email. Please check your inbox.');
            }catch(err){ console.error('send-otp error', err); alert('Failed to send OTP'); }
          });
        }

        if(verifyOtpBtnEl){
          verifyOtpBtnEl.addEventListener('click', async ()=>{
            const code = document.getElementById('otpInput').value.trim();
            if(!pending){ alert('No signup in progress. Please request an OTP first.'); return; }
            if(!code || code.length !== 6){ alert('Please enter the 6-digit OTP'); return; }
            try{
              const r = await fetch('/api/verify-otp', { method:'POST', headers:{ 'content-type':'application/json' }, body: JSON.stringify({ token: pending.token, otp: code }) });
              const j = await r.json();
              if(!r.ok){ console.error('verify-otp failed', j); alert('OTP verification failed: '+(j.error||'invalid')); return; }
              // OTP verified â€” create Firebase user now
              console.log('OTP verified, attempting to create Firebase user...', pending);
              try{
                if(!auth){ console.error('Firebase auth not initialized'); alert('Firebase auth not available. Please refresh and try again.'); return; }
                if(!db){ console.error('Firebase db not initialized'); alert('Firebase database not available. Please refresh and try again.'); return; }
                console.log('Creating user with:', pending.email);
                try{
                  const cred = await createUserWithEmailAndPassword(auth, pending.email, pending.password);
                  console.log('User created:', cred.user.uid);
                  await updateProfile(cred.user, { displayName: pending.name });
                  console.log('Profile updated');
                  // Mark the RTDB users node as OTP-verified so onAuthStateChanged allows login
                  await set(ref(db, `users/${cred.user.uid}`), { name: pending.name, email: pending.email, otpVerified: true, createdAt: Date.now() });
                  console.log('RTDB user node created (otpVerified:true)');
                  // Immediately update UI before closing auth modal
                  setCurrentUser({ uid: cred.user.uid, email: cred.user.email, name: pending.name });
                  try{ startChatListener(); }catch(e){ console.error('startChatListener after signup failed', e); }
                  closeAuth();
                  pending = null;
                  document.getElementById('otpInput').value = '';
                  alert('Account created and verified! You can now log in.');
                }catch(createErr){
                  // If account already exists, try to log in instead
                  if(createErr.code === 'auth/email-already-in-use'){
                    console.log('Account already exists, attempting to sign in...');
                    try{
                      const signed = await signInWithEmailAndPassword(auth, pending.email, pending.password);
                      console.log('Signed in successfully');
                      // Ensure users node marks otpVerified so the auth listener won't sign the user out
                      try{ await update(ref(db, `users/${signed.user.uid}`), { name: pending.name || signed.user.displayName || '', email: pending.email, otpVerified: true }); }catch(e){ console.warn('Failed to set otpVerified on existing user', e); }
                      // Immediately update UI before closing auth modal
                      const userName = pending.name || signed.user.displayName || '';
                      setCurrentUser({ uid: signed.user.uid, email: signed.user.email, name: userName });
                      try{ startChatListener(); }catch(e){ console.error('startChatListener after login failed', e); }
                      closeAuth();
                      pending = null;
                      document.getElementById('otpInput').value = '';
                      alert('Account exists. You have been logged in!');
                    }catch(signInErr){
                      console.error('Sign in failed:', signInErr);
                      alert('Account exists but sign in failed. Please use the login form. Error: '+signInErr.message);
                    }
                  } else {
                    console.error('Account creation failed:', createErr);
                    alert('Failed to create account: '+createErr.message);
                  }
                }
              }catch(err){ console.error('createUser after OTP failed:', err); alert('Failed to create account: '+err.message); }
            }catch(err){ console.error('verify-otp error', err); alert('OTP verify failed: '+err.message); }
          });
        }

        // Prevent the regular submit from creating user directly
        _signupForm.addEventListener('submit', (e)=>{ e.preventDefault(); alert('Use the Send OTP button to start signup.'); });
      } else {
        // Firebase not enabled: fallback to local/demo signup is handled elsewhere in the page
      }
    }
  }catch(e){ console.error('setup auth handlers', e); }
  }
</script>
</body>
</html>
